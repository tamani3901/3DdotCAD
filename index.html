<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>Voxelエディタ with 画像機能フル版</title>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
            background-color: #222;
            color: #fff;
            overscroll-behavior: none;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            background: #333;
        }
        #top-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        #tab-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        .tab-content {
            display: none;
            flex-wrap: wrap;
            gap: 10px;
            padding: 5px 0;
            align-items: center;
        }
        .tab-content.active {
            display: flex;
        }
        #controls button,
        #controls input[type="color"],
        #controls input[type="number"],
        #controls input[type="range"],
        #controls input[type="file"] {
            padding: 5px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            background-color: #444;
            color: #fff;
            cursor: pointer;
        }
        #controls button:hover,
        .custom-file-label:hover {
            background-color: #666;
        }
        .tab-button.active {
            background-color: #007bff;
        }
        #grid-container {
            width: 80vw;
            height: 70vh;
            overflow: auto;
            border: 2px solid #444;
            margin: 10px;
            position: relative;
        }
        #grid-wrapper {
            position: relative;
        }
        #grid {
            position: relative;
            z-index: 20;
            display: grid;
            touch-action: none;
        }
        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #555;
            box-sizing: border-box;
            position: relative;
        }
        .cell-highlight {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.2);
            pointer-events: none;
        }
        #selection-box {
            position: absolute;
            background-color: rgba(0, 100, 255, 0.4);
            border: 1px dashed rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 50;
        }
        .selecting-cell, .selected-cell {
            opacity: 0.8;
            border: 1px solid rgba(255, 255, 255, 0.8) !important;
        }
        /* 選択完了後の移動ボックスの半透明表示（要望②に対応） */
        .moving-box {
            background-color: rgba(255, 255, 255, 0.1) !important;
            border: 2px dashed rgba(255, 255, 255, 0.8) !important;
            pointer-events: auto; /* 移動できるようにする */
        }
        /* 図形配置モードのプレビューは、描画色で半透明に */
        .shape-preview-cell {
            opacity: 0.5 !important;
            border: 1px solid rgba(255, 255, 255, 0.8) !important;
        }
        #renderer-container {
            display: none;
            width: 80vw;
            height: 70vh;
            margin: 10px;
            border: 2px solid #444;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #scrollButtons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }
        #scrollButtons button {
            background-color: #555;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            font-size: 16px;
        }
        #scrollButtons button:hover {
            background-color: #888;
        }
        .overlay-image {
            position: absolute;
            opacity: 0.3;
            pointer-events: none;
            z-index: 1;
            user-select: none;
        }
        .overlay-image.moving {
            opacity: 0.5;
            pointer-events: none;
            z-index: 10;
            cursor: move;
        }
        .custom-file-label {
            padding: 6px 12px;
            background-color: #444;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            display: inline-block;
            font-size: 14px;
            border: none;
            transition: background-color 0.3s ease;
        }
        .custom-file-label:hover {
            background-color: #666;
        }
        #sideSelection {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background: #444;
            border: 1px solid #666;
            z-index: 1001;
            border-radius: 8px;
            text-align: center;
        }
        #sideSelection p {
            margin-top: 0;
        }
        #sideSelection button {
            margin: 5px;
            padding: 8px 15px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #shapeControls {
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div id="top-controls">
            <div id="tab-buttons">
                <button class="tab-button active" data-tab="drawTab">描画</button>
                <button class="tab-button" data-tab="selectMoveTab">選択移動</button>
                <button class="tab-button" data-tab="insertTab">挿入</button>
                <button class="tab-button" data-tab="convertTab">変換</button>
                <button class="tab-button" data-tab="exportTab">エクスポート</button>
            </div>
            <button id="show2dBtn">2D表示</button>
            <button id="show3dBtn">3D表示</button>
            <input type="number" id="inputWidth" value="16" min="1" max="64" />×
            <input type="number" id="inputHeight" value="16" min="1" max="64" />×
            <input type="number" id="inputDepth" value="16" min="1" max="64" />
            <button id="resizeBtn">サイズ変更</button>
            <button id="layerPrevBtn">↑</button>
            <button id="layerNextBtn">↓</button>
            <span id="layerLabel"></span>
        </div>

        <div id="drawTab" class="tab-content active">
            <input type="color" id="colorPicker" value="#ff0000" />
            <button id="drawBtn">描画</button>
            <button id="eraseBtn">消去</button>
            <input type="range" id="brushSize" min="1" max="5" value="1" />
            <span id="brushSizeValue">1</span>
            
            <button id="circleShapeBtn">円</button>
            <button id="squareShapeBtn">四角</button>
            <button id="triangleShapeBtn">三角</button>
            
            <div id="shapeControls" style="display:none;">
                <button id="shapeSizeMinus">-</button>
                <span id="shapeSizeLabel">サイズ: 5</span>
                <button id="shapeSizePlus">+</button>
                <button id="shapeRotateBtn" style="display:none;">回転</button>
                <button id="placeShapeBtn">配置完了</button>
            </div>
        </div>

        <div id="selectMoveTab" class="tab-content">
            <button id="selectBtn">選択</button>
            <button id="completeSelectionBtn" style="display:none;">選択完了</button>
            <button id="cancelSelectionBtn" style="display:none;">キャンセル</button>
            <button id="copyBtn">コピー</button>
            <button id="cutBtn">カット</button>
            <button id="pasteBtn">ペースト</button>
            <button id="copyLayerAddBtn">レイヤーコピーして追加</button>
        </div>
        <div id="insertTab" class="tab-content">
            <input type="file" id="importJsonInput" accept=".json" style="display:none;" />
            <label for="importJsonInput" class="custom-file-label">JSONインポート</label>
            <input type="file" id="imageInput" accept="image/*" style="display:none;" />
            <label for="imageInput" class="custom-file-label">画像インポート</label>
        </div>

        <div id="convertTab" class="tab-content">
            <button id="convertImageTo3dBtn">画像3D変換</button>
            <input type="number" id="imgWidth" value="100" style="width: 60px;" />×
            <input type="number" id="imgHeight" value="100" style="width: 60px;" />
            <button id="applyImageSize">画像サイズ変更</button>
            X: <input type="number" id="imgOffsetX" value="0" style="width: 40px;" />
            Y: <input type="number" id="imgOffsetY" value="0" style="width: 40px;" />
            <button id="toggleMoveImage">画像移動モード: OFF</button>
            <button id="deleteImageBtn">画像削除</button>
        </div>

        <div id="exportTab" class="tab-content">
            <button id="saveObjBtn">OBJエクスポート</button>
            <button id="saveJsonBtn">JSONエクスポート</button>
            <button id="save3dImageBtn">スクショ</button>
        </div>
    </div>

    <div id="grid-container">
        <div id="grid-wrapper">
            <div id="grid"></div>
            <div id="selection-box" style="display:none;"></div>
        </div>
    </div>

    <div id="renderer-container">
        <canvas id="threejs-canvas"></canvas>
    </div>

    <div id="sideSelection">
        <p>どの面に画像を配置しますか？</p>
        <button data-side="front">前面</button>
        <button data-side="back">背面</button>
        <button data-side="left">左面</button>
        <button data-side="right">右面</button>
        <button data-side="top">上面</button>
        <button data-side="bottom">下面</button>
        <button data-side="cancel">キャンセル</button>
    </div>

    <div id="scrollButtons">
        <button id="scrollUp">↑</button>
        <button id="scrollDown">↓</button>
        <button id="scrollLeft">←</button>
        <button id="scrollRight">→</button>
        <button id="undoBtn">元に戻す</button>
        <button id="resetBtn">リセット</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let width = 16, height = 16, depth = 16;
        let currentLayer = 0;
        let drawColor = "#ff0000";
        let isErasing = false;
        let brushSize = 1;
        let voxelData = [];
        let scene, camera, renderer, controls;
        let is3DInitialized = false;
        let voxelMeshes = [];
        let undoStack = [];
        let cells = [];
        let overlayImage = null;
        let isImageMoveMode = false;
        let dragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let imgStartLeft = 0;
        let imgStartTop = 0;
        
        let clipboard = []; // クリップボード用 (要望③)
        let currentShape = { type: 'none', x: -1, z: -1, size: 5, angle: 0 }; // 図形配置用 (要望④,⑤)
        let isShapeMoving = false; // 図形移動中フラグ (要望⑤)
        let previousPreviewCells = []; // <--- FIX 1: 図形プレビューセルの保存用

        const grid = document.getElementById("grid");
        const layerLabel = document.getElementById("layerLabel");
        const canvas = document.getElementById("threejs-canvas");
        const rendererContainer = document.getElementById("renderer-container");
        const gridContainer = document.getElementById("grid-container");
        const gridWrapper = document.getElementById("grid-wrapper");
        const imageInput = document.getElementById('imageInput');
        const imgWidthInput = document.getElementById('imgWidth');
        const imgHeightInput = document.getElementById('imgHeight');
        const applyImageSizeBtn = document.getElementById('applyImageSize');
        const toggleMoveImageBtn = document.getElementById('toggleMoveImage');
        const deleteImageBtn = document.getElementById('deleteImageBtn');
        const convertImageTo3dBtn = document.getElementById('convertImageTo3dBtn');
        const sideSelectionDiv = document.getElementById('sideSelection');
        const imgOffsetXInput = document.getElementById('imgOffsetX'); // 新規 (要望①)
        const imgOffsetYInput = document.getElementById('imgOffsetY'); // 新規 (要望①)
        
        let currentMode = 'draw';
        let isDrawing = false;
        let isSelecting = false;
        let isMoving = false;
        let startCellX, startCellZ;
        let selectedCells = [];
        let selectedVoxelData = [];
        let movingStartMouseX, movingStartMouseY;
        let movingStartGridX, movingStartGridZ;

        const selectBtn = document.getElementById('selectBtn');
        const drawBtn = document.getElementById('drawBtn');
        const eraseBtn = document.getElementById('eraseBtn');
        const completeSelectionBtn = document.getElementById('completeSelectionBtn');
        const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
        const selectionBox = document.getElementById('selection-box');
        const copyBtn = document.getElementById('copyBtn');
        const cutBtn = document.getElementById('cutBtn');
        const pasteBtn = document.getElementById('pasteBtn');
        const copyLayerAddBtn = document.getElementById('copyLayerAddBtn');
        
        // --- 図形操作ボタン ---
        const circleShapeBtn = document.getElementById('circleShapeBtn');
        const squareShapeBtn = document.getElementById('squareShapeBtn');
        const triangleShapeBtn = document.getElementById('triangleShapeBtn');
        const shapeControlsDiv = document.getElementById('shapeControls');
        const shapeSizeLabel = document.getElementById('shapeSizeLabel');
        const shapeSizePlus = document.getElementById('shapeSizePlus');
        const shapeSizeMinus = document.getElementById('shapeSizeMinus');
        const placeShapeBtn = document.getElementById('placeShapeBtn');
        const shapeRotateBtn = document.getElementById('shapeRotateBtn');
        
        // --- タブ切り替えのロジック ---
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));

                button.classList.add('active');
                const targetTab = document.getElementById(button.dataset.tab);
                
                if (targetTab) {
                    targetTab.classList.add('active');
                }
                
                // 図形コントロールをリセット
                shapeControlsDiv.style.display = 'none';
                currentShape.type = 'none';
                // 図形プレビューのスタイルをリセット
                previousPreviewCells.forEach(cell => {
                    cell.classList.remove('shape-preview-cell');
                    const x = parseInt(cell.dataset.x);
                    const z = parseInt(cell.dataset.z);
                    const color = voxelData[currentLayer][z]?.[x];
                    cell.style.backgroundColor = color ?? "transparent";
                });
                previousPreviewCells = [];
                cells.flat().forEach(c => c.classList.remove('selecting-cell'));
                
                if (button.dataset.tab === 'drawTab') {
                    setMode('draw');
                } else if (button.dataset.tab === 'selectMoveTab') {
                    setMode('select');
                } else {
                    setMode('none');
                }
            });
        });

        function setMode(mode) {
            currentMode = mode;
            
            // 図形ボタンの表示/非表示を切り替え
            const isDrawTab = document.getElementById('drawTab').classList.contains('active');
            circleShapeBtn.style.display = isDrawTab ? 'inline-block' : 'none';
            squareShapeBtn.style.display = isDrawTab ? 'inline-block' : 'none';
            triangleShapeBtn.style.display = isDrawTab ? 'inline-block' : 'none';
            
            completeSelectionBtn.style.display = 'none';
            cancelSelectionBtn.style.display = 'none';

            document.querySelectorAll('#drawTab button, #selectMoveTab button').forEach(btn => btn.style.backgroundColor = '');
            
            if (mode === 'draw') {
                drawBtn.style.backgroundColor = '#666';
                isErasing = false;
            } else if (mode === 'erase') {
                eraseBtn.style.backgroundColor = '#666';
                isErasing = true;
            } else if (mode === 'select' || mode === 'move') {
                selectBtn.style.backgroundColor = '#666';
                completeSelectionBtn.style.display = 'inline-block';
                cancelSelectionBtn.style.display = 'inline-block';
            }
            
            if (mode !== 'select' && mode !== 'move') {
                clearSelection(true); // モードが変わったら選択解除
            }
        }
        
        function clearSelection(clearBox) {
            selectedCells = [];
            selectedVoxelData = [];
            isSelecting = false;
            isMoving = false;
            if (clearBox) {
                selectionBox.style.display = 'none';
            }
            selectionBox.classList.remove('moving-box');
            cells.flat().forEach(cell => {
                cell.classList.remove('selecting-cell');
            });
            updateGridColors();
        }
        
        function getCellFromPoint(clientX, clientY) {
            const rect = grid.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            const cellX = Math.floor(x / 20);
            const cellZ = Math.floor(y / 20);
            if (cellX >= 0 && cellX < width && cellZ >= 0 && cellZ < depth) {
                return cells[cellZ][cellX];
            }
            return null;
        }

        // --- 図形描画ロジック (要望⑥) ---
        function calculateShapeVoxels(shape, centerX, centerZ, size, angle) {
            const voxels = [];
            const color = drawColor;
            
            for (let z = 0; z < depth; z++) {
                for (let x = 0; x < width; x++) {
                    let isInside = false;
                    
                    if (shape === 'square') {
                        const halfSize = Math.floor(size / 2);
                        if (x >= centerX - halfSize && x <= centerX + halfSize &&
                            z >= centerZ - halfSize && z <= centerZ + halfSize) {
                            isInside = true;
                        }
                    } else if (shape === 'circle') {
                        const radius = size / 2;
                        // 円の自動計算
                        const distSq = (x - centerX) * (x - centerX) + (z - centerZ) * (z - centerZ);
                        if (distSq < radius * radius) {
                            isInside = true;
                        }
                    } else if (shape === 'triangle') {
                        // 三角形の自動計算
                        const halfSize = size / 2;
                        let v1 = { x: centerX, z: centerZ - halfSize }; // Top
                        let v2 = { x: centerX - halfSize, z: centerZ + halfSize }; // Bottom Left
                        let v3 = { x: centerX + halfSize, z: centerZ + halfSize }; // Bottom Right
                        
                        // バリセントリック座標系や外積による判定
                        const sign = (p1, p2, p3) => (p1.x - p3.x) * (p2.z - p3.z) - (p2.x - p3.x) * (p1.z - p3.z);
                        const pt = { x, z };
                        const d1 = sign(pt, v1, v2);
                        const d2 = sign(pt, v2, v3);
                        const d3 = sign(pt, v3, v1);
                        
                        const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
                        const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
                        
                        if (!(hasNeg && hasPos)) {
                            isInside = true;
                        }
                    }

                    if (isInside) {
                        voxels.push({ x, z, color });
                    }
                }
            }
            return voxels;
        }

        // 図形プレビューの描画 (要望⑤)
        function renderShapePreview() {
            // <--- FIX 1: 前回のプレビューセルのスタイルをリセット
            previousPreviewCells.forEach(cell => {
                cell.classList.remove('shape-preview-cell');
                const x = parseInt(cell.dataset.x);
                const z = parseInt(cell.dataset.z);
                const color = voxelData[currentLayer][z]?.[x];
                cell.style.backgroundColor = color ?? "transparent"; // Voxel Dataの色に戻す
            });
            previousPreviewCells = [];

            if (currentShape.type === 'none') return;
            
            const voxels = calculateShapeVoxels(currentShape.type, currentShape.x, currentShape.z, currentShape.size, currentShape.angle);
            voxels.forEach(v => {
                if (v.x >= 0 && v.x < width && v.z >= 0 && v.z < depth) {
                    const cell = cells[v.z][v.x];
                    cell.classList.add('shape-preview-cell');
                    cell.style.backgroundColor = drawColor; // <--- FIX 1: 現在の描画色で一時的に上書き
                    previousPreviewCells.push(cell);
                }
            });
            // 選択セルのハイライトを解除 (shapeとselectionの重複を避けるため)
            cells.flat().forEach(c => c.classList.remove('selecting-cell')); 
        }
        
        // 図形配置モードへの切り替え (要望④)
        function enterShapePlacementMode(type) {
            setMode('none');
            currentMode = 'shape'; // 新しいモード
            currentShape.type = type;
            currentShape.x = Math.floor(width / 2); 
            currentShape.z = Math.floor(depth / 2);
            currentShape.size = 5;
            currentShape.angle = 0;
            
            shapeControlsDiv.style.display = 'flex';
            shapeSizeLabel.textContent = `サイズ: ${currentShape.size}`;
            shapeRotateBtn.style.display = (type === 'triangle') ? 'inline-block' : 'none';
            renderShapePreview();
        }

        // 図形の配置実行 (要望⑤)
        function placeShape() {
            if (currentShape.type === 'none') return;
            saveStateForUndo();
            
            const voxels = calculateShapeVoxels(currentShape.type, currentShape.x, currentShape.z, currentShape.size, currentShape.angle);
            
            voxels.forEach(v => {
                if (v.x >= 0 && v.x < width && v.z >= 0 && v.z < depth) {
                     voxelData[currentLayer][v.z][v.x] = v.color;
                }
            });
            
            updateGridColors();
            if (is3DInitialized) update3DView();
            
            // 図形モード終了
            shapeControlsDiv.style.display = 'none';
            currentShape.type = 'none';
            // <--- FIX 1: 最終的な後処理（スタイルリセットはrenderShapePreviewで完了済み）
            previousPreviewCells.forEach(cell => {
                cell.classList.remove('shape-preview-cell');
                // この時点でvoxelDataが更新されているので、updateGridColorsが呼ばれればスタイルはクリアされる
            });
            previousPreviewCells = [];
            cells.flat().forEach(c => c.classList.remove('selecting-cell'));
            setMode('draw');
        }


        // --- イベントリスナー ---

        selectBtn.addEventListener('click', () => {
            setMode('select');
            clearSelection(true);
        });
        drawBtn.addEventListener('click', () => {
            isErasing = false;
            setMode('draw');
        });
        eraseBtn.addEventListener('click', () => {
            isErasing = true;
            setMode('erase');
        });
        cancelSelectionBtn.addEventListener('click', () => {
            if (currentMode === 'move' && selectedVoxelData.length > 0) {
                // 移動モード中にキャンセルされた場合、元の位置に戻す
                const currentBoxX = parseInt(selectionBox.style.left) / 20;
                const currentBoxZ = parseInt(selectionBox.style.top) / 20;

                selectedVoxelData.forEach(voxel => {
                    const originalX = currentBoxX + voxel.x;
                    const originalZ = currentBoxZ + voxel.z;
                    if (originalX >= 0 && originalX < width && originalZ >= 0 && originalZ < depth) {
                        voxelData[currentLayer][originalZ][originalX] = voxel.color; // 元の場所に戻す（この処理はカット時のみ意味を持つ）
                    }
                });
                
                // 元の状態を復元するため、Undo
                undo();
            }
            clearSelection(true);
            setMode('select');
        });
        
        // 図形プリセットのイベント (要望④)
        circleShapeBtn.addEventListener('click', () => enterShapePlacementMode('circle'));
        squareShapeBtn.addEventListener('click', () => enterShapePlacementMode('square'));
        triangleShapeBtn.addEventListener('click', () => enterShapePlacementMode('triangle'));
        
        // サイズ変更ボタン (要望⑤)
        shapeSizePlus.addEventListener('click', () => {
            if (currentShape.type !== 'none') {
                currentShape.size = Math.min(width, depth, currentShape.size + 1);
                shapeSizeLabel.textContent = `サイズ: ${currentShape.size}`;
                renderShapePreview();
            }
        });
        shapeSizeMinus.addEventListener('click', () => {
            if (currentShape.type !== 'none') {
                currentShape.size = Math.max(1, currentShape.size - 1);
                shapeSizeLabel.textContent = `サイズ: ${currentShape.size}`;
                renderShapePreview();
            }
        });
        
        // 配置完了ボタン (要望⑤)
        placeShapeBtn.addEventListener('click', placeShape);


        // --- クリップボード機能 (要望③) ---
        copyBtn.addEventListener('click', () => {
            if (currentMode === 'move' && selectedVoxelData.length > 0) {
                // selectedVoxelDataは既に相対座標なのでそのままコピー
                clipboard = JSON.parse(JSON.stringify(selectedVoxelData));
                console.log('コピーしました');
            }
        });

        cutBtn.addEventListener('click', () => {
            if (currentMode === 'move' && selectedVoxelData.length > 0) {
                saveStateForUndo(); // カット前の状態を保存
                // 1. クリップボードにコピー
                clipboard = JSON.parse(JSON.stringify(selectedVoxelData));
                
                // 2. 元の場所をクリア
                const currentBoxX = parseInt(selectionBox.style.left) / 20;
                const currentBoxZ = parseInt(selectionBox.style.top) / 20;
                
                selectedVoxelData.forEach(voxel => {
                    const originalX = currentBoxX + voxel.x;
                    const originalZ = currentBoxZ + voxel.z;
                    if (originalX >= 0 && originalX < width && originalZ >= 0 && originalZ < depth) {
                        voxelData[currentLayer][originalZ][originalX] = null;
                    }
                });

                // 3. 選択状態をクリアし、移動モードは維持
                updateGridColors(); // 元の場所が消えたことを反映
                // clearSelection(true); // 移動モードを維持するため、クリアしない
                selectionBox.style.display = 'block';
                selectionBox.classList.add('moving-box');
                setMode('move');
                console.log('カットしました。移動モードに移行');
            }
        });

        pasteBtn.addEventListener('click', () => {
            if (clipboard.length === 0) return;
            
            // <--- FIX 2: 既存の選択があればクリアし、ペーストしたものを新しい選択とする
            clearSelection(true); 

            const pasteX = Math.floor(width / 2); 
            const pasteZ = Math.floor(depth / 2);
            
            // クリップボードの相対座標をselectedVoxelDataに設定 (voxelDataへの描画はしない)
            selectedVoxelData = JSON.parse(JSON.stringify(clipboard));
            selectedCells = []; // 最終的なセル位置はまだないのでクリアしておく

            // バウンディングボックスの計算
            let minRelX = width, maxRelX = 0, minRelZ = depth, maxRelZ = 0;
            selectedVoxelData.forEach(voxel => {
                minRelX = Math.min(minRelX, voxel.x);
                maxRelX = Math.max(maxRelX, voxel.x);
                minRelZ = Math.min(minRelZ, voxel.z);
                maxRelZ = Math.max(maxRelZ, voxel.z);
            });
            
            const startX = pasteX + minRelX;
            const startZ = pasteZ + minRelZ;
            const boxWidth = (maxRelX - minRelX + 1) * 20;
            const boxHeight = (maxRelZ - minRelZ + 1) * 20;

            // 描画はせず、移動用のボックスを設定
            if (selectedVoxelData.length > 0) {
                selectionBox.style.left = `${startX * 20}px`;
                selectionBox.style.top = `${startZ * 20}px`;
                selectionBox.style.width = `${boxWidth}px`;
                selectionBox.style.height = `${boxHeight}px`;
                selectionBox.style.display = 'block';
                selectionBox.classList.add('moving-box');

                setMode('move');
                console.log('ペースト準備完了。移動モードに移行');
            }
        });

        completeSelectionBtn.addEventListener('click', () => {
            if (isSelecting) {
                isSelecting = false;
                const rect = selectionBox.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                const startX = Math.round((rect.left - gridRect.left) / 20);
                const startZ = Math.round((rect.top - gridRect.top) / 20);
                const endX = startX + Math.round(rect.width / 20) - 1;
                const endZ = startZ + Math.round(rect.height / 20) - 1;
                selectedCells = [];
                selectedVoxelData = [];
                
                for (let z = startZ; z <= endZ; z++) {
                    for (let x = startX; x <= endX; x++) {
                        const color = voxelData[currentLayer][z]?.[x];
                        if (color) {
                            selectedCells.push({ x, z, color });
                            // 相対座標で保存
                            selectedVoxelData.push({ x: x - startX, z: z - startZ, color }); 
                        }
                    }
                }
                
                // 元の場所からボクセルを削除
                selectedCells.forEach(cell => {
                    voxelData[currentLayer][cell.z][cell.x] = null;
                });
                updateGridColors();
                
                // 選択ボックスを移動可能にする (要望②の半透明はCSSで対応済み)
                selectionBox.style.display = 'block';
                selectionBox.classList.add('moving-box');
                setMode('move');
                return;
            }
            if (currentMode === 'move' && selectedVoxelData.length > 0) {
                // 移動完了を明示的に行う
                moveSelectedCells(0, 0); // 移動量0で最終確定
                clearSelection(true);
                setMode('select');
            }
        });
        
        // --- マウス/タッチイベント (図形移動の処理追加) (要望⑤) ---
        grid.addEventListener('mousedown', handlePointerDown);
        grid.addEventListener('mousemove', handlePointerMove);
        window.addEventListener('mouseup', handlePointerUp);

        grid.addEventListener('touchstart', (e) => handlePointerDown(e.touches[0], e), { passive: false });
        grid.addEventListener('touchmove', (e) => handlePointerMove(e.touches[0], e), { passive: false });
        window.addEventListener('touchend', (e) => handlePointerUp(e.changedTouches[0], e));

        function handlePointerDown(e, originalEvent) {
            const clientX = e.clientX;
            const clientY = e.clientY;
            const cell = getCellFromPoint(clientX, clientY);
            if (!cell) return;
            const x = parseInt(cell.dataset.x);
            const z = parseInt(cell.dataset.z);

            if (currentMode === 'draw' || currentMode === 'erase') {
                originalEvent.preventDefault();
                isDrawing = true;
                paintCells(x, z);
            } else if (currentMode === 'select') {
                isSelecting = true;
                startCellX = x;
                startCellZ = z;
                selectionBox.style.display = 'block';
                selectionBox.classList.remove('moving-box');
                selectionBox.style.left = `${x * 20}px`;
                selectionBox.style.top = `${z * 20}px`;
                selectionBox.style.width = '20px';
                selectionBox.style.height = '20px';
                originalEvent.preventDefault();
            } else if (currentMode === 'move') {
                const selectionBoxRect = selectionBox.getBoundingClientRect();
                if (selectionBoxRect.left <= clientX && clientX <= selectionBoxRect.right &&
                    selectionBoxRect.top <= clientY && clientY <= selectionBoxRect.bottom) {
                    
                    isMoving = true;
                    // saveStateForUndo() は moveSelectedCells (mouse up) に移動 <-- FIX 2
                    movingStartMouseX = clientX;
                    movingStartMouseY = clientY;
                    movingStartGridX = parseInt(selectionBox.style.left) / 20;
                    movingStartGridZ = parseInt(selectionBox.style.top) / 20;
                    originalEvent.preventDefault();
                } else {
                    // ボックス外をクリックしたら移動を確定して新しい選択へ
                    if (selectedVoxelData.length > 0) {
                        moveSelectedCells(0, 0); // 現在位置で確定
                    }
                    clearSelection(true);
                    setMode('select');
                }
            } else if (currentMode === 'shape') { // 図形移動の追加 (要望⑤)
                isShapeMoving = true;
                movingStartMouseX = clientX;
                movingStartMouseY = clientY;
                movingStartGridX = currentShape.x;
                movingStartGridZ = currentShape.z;
                originalEvent.preventDefault();
            }
        }

        function handlePointerMove(e, originalEvent) {
            const clientX = e.clientX;
            const clientY = e.clientY;

            if (currentMode === 'draw' || currentMode === 'erase') {
                if (!isDrawing) return;
                originalEvent.preventDefault();
                const targetElement = document.elementFromPoint(clientX, clientY);
                if (targetElement && targetElement.classList.contains("cell")) {
                    const moveX = parseInt(targetElement.dataset.x);
                    const moveZ = parseInt(targetElement.dataset.z);
                    paintCells(moveX, moveZ);
                }
            } else if (currentMode === 'select') {
                if (isSelecting) {
                    originalEvent.preventDefault();
                    const cell = getCellFromPoint(clientX, clientY);
                    if (!cell) return;
                    const endX = parseInt(cell.dataset.x);
                    const endZ = parseInt(cell.dataset.z);
                    const minX = Math.min(startCellX, endX);
                    const maxX = Math.max(startCellX, endX);
                    const minZ = Math.min(startCellZ, endZ);
                    const maxZ = Math.max(startCellZ, endZ);
                    selectionBox.style.left = `${minX * 20}px`;
                    selectionBox.style.top = `${minZ * 20}px`;
                    selectionBox.style.width = `${(maxX - minX + 1) * 20}px`;
                    selectionBox.style.height = `${(maxZ - minZ + 1) * 20}px`;
                    cells.flat().forEach(c => c.classList.remove('selecting-cell'));
                    for (let z = minZ; z <= maxZ; z++) {
                        for (let x = minX; x <= maxX; x++) {
                            if (cells[z] && cells[z][x]) {
                                cells[z][x].classList.add('selecting-cell');
                            }
                        }
                    }
                }
            } else if (currentMode === 'move' && isMoving) {
                originalEvent.preventDefault();
                const dx = Math.round((clientX - movingStartMouseX) / 20);
                const dy = Math.round((clientY - movingStartMouseY) / 20);
                const newX = movingStartGridX + dx;
                const newZ = movingStartGridZ + dy;
                selectionBox.style.left = `${newX * 20}px`;
                selectionBox.style.top = `${newZ * 20}px`;
            } else if (currentMode === 'shape' && isShapeMoving) { // 図形移動の追加 (要望⑤)
                originalEvent.preventDefault();
                const dx = Math.round((clientX - movingStartMouseX) / 20);
                const dy = Math.round((clientY - movingStartMouseY) / 20);
                
                let newX = movingStartGridX + dx;
                let newZ = movingStartGridZ + dy;
                
                // 範囲制限
                newX = Math.max(0, Math.min(width - 1, newX));
                newZ = Math.max(0, Math.min(depth - 1, newZ));
                
                if (newX !== currentShape.x || newZ !== currentShape.z) {
                    currentShape.x = newX;
                    currentShape.z = newZ;
                    renderShapePreview();
                }
            }
        }

        function handlePointerUp(e, originalEvent) {
            isDrawing = false;
            
            if (currentMode === 'move' && isMoving) {
                const dx = Math.round((e.clientX - movingStartMouseX) / 20);
                const dy = Math.round((e.clientY - movingStartMouseY) / 20);
                moveSelectedCells(dx, dy); // 最終確定
                isMoving = false;
            } else if (currentMode === 'shape' && isShapeMoving) { // 図形移動の終了
                isShapeMoving = false;
            }
        }
        
        function moveSelectedCells(dx, dy) {
            if (selectedVoxelData.length === 0) return;
            
            // <--- FIX 2: 最終確定時にUndoスタックに保存
            saveStateForUndo(); 
            
            const currentBoxX = parseInt(selectionBox.style.left) / 20;
            const currentBoxZ = parseInt(selectionBox.style.top) / 20;
            
            const newSelectedVoxelData = [];
            selectedCells = [];
            
            selectedVoxelData.forEach(voxel => {
                const newX = currentBoxX + voxel.x;
                const newZ = currentBoxZ + voxel.z;
                
                if (newX >= 0 && newX < width && newZ >= 0 && newZ < depth) {
                    voxelData[currentLayer][newZ][newX] = voxel.color;
                    selectedCells.push({ x: newX, z: newZ, color: voxel.color });
                    newSelectedVoxelData.push({ x: voxel.x, z: voxel.z, color: voxel.color }); // 相対座標を維持
                }
            });
            
            selectedVoxelData = newSelectedVoxelData;
            updateGridColors();
            if (is3DInitialized) update3DView();
            
            // ボックスを非表示にしたい場合はここで clearSelection(true) を呼ぶ
            // ここでは移動確定なので、このまま移動モードを維持しても良いが、Complete Selectionを押したのと同じ動きにする
            clearSelection(true);
            setMode('select');
        }
        
        // --- Voxelデータ操作のコア関数 ---

        function initData() {
            voxelData = Array.from({ length: height }, () =>
                Array.from({ length: depth }, () =>
                    Array.from({ length: width }, () => null)
                )
            );
        }

        function initGrid() {
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${width}, 20px)`;
            grid.style.width = `${width * 20}px`;
            grid.style.height = `${depth * 20}px`;
            cells = [];
            for (let z = 0; z < depth; z++) {
                cells[z] = [];
                for (let x = 0; x < width; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.z = z;
                    grid.appendChild(cell);
                    cells[z][x] = cell;
                }
            }
        }

        function updateGridColors() {
            if (cells.length === 0) return;
            for (let z = 0; z < depth; z++) {
                for (let x = 0; x < width; x++) {
                    const cell = cells[z][x];
                    const color = voxelData[currentLayer][z]?.[x];
                    cell.style.backgroundColor = color ?? "transparent"; // Voxel Dataの色を優先
                    const isSelected = selectedCells.some(c => c.x === x && c.z === z);
                    cell.classList.toggle('selected-cell', isSelected);
                    
                    // FIX 1: renderShapePreviewが直接スタイルを上書きするため、ここでは何もしない
                    // 以前の図形プレビュー上書きロジックを削除
                }
            }
        }

        function paintCells(centerX, centerZ) {
            saveStateForUndo();
            const halfSize = Math.floor(brushSize / 2);
            const color = isErasing ? null : drawColor;
            
            for (let z = centerZ - halfSize; z <= centerZ + halfSize; z++) {
                for (let x = centerX - halfSize; x <= centerX + halfSize; x++) {
                    if (x >= 0 && x < width && z >= 0 && z < depth && currentLayer >= 0 && currentLayer < height) {
                        voxelData[currentLayer][z][x] = color;
                    }
                }
            }
            updateGridColors();
            if (is3DInitialized) update3DView();
        }

        function updateLayerLabel() {
            layerLabel.textContent = `レイヤー: ${currentLayer + 1} / ${height}`;
        }

        function resizeData(newWidth, newHeight, newDepth) {
            const newVoxelData = Array.from({ length: newHeight }, (_, y) =>
                Array.from({ length: newDepth }, (_, z) =>
                    Array.from({ length: newWidth }, (_, x) => {
                        if (y < height && z < depth && x < width) {
                            return voxelData[y][z][x];
                        }
                        return null;
                    })
                )
            );
            width = newWidth;
            height = newHeight;
            depth = newDepth;
            voxelData = newVoxelData;
            currentLayer = Math.min(currentLayer, height - 1);
            initGrid();
            updateLayerLabel();
            updateGridColors();
            if (is3DInitialized) update3DView();
        }

        function saveStateForUndo() {
            const dataToSave = JSON.parse(JSON.stringify(voxelData));
            undoStack.push(dataToSave);
            if (undoStack.length > 20) {
                undoStack.shift();
            }
        }

        function undo() {
            if (undoStack.length > 0) {
                voxelData = undoStack.pop();
                updateGridColors();
                if (is3DInitialized) update3DView();
            }
        }
        
        // --- 3D表示機能 ---

        function init3DView() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            camera = new THREE.PerspectiveCamera(75, rendererContainer.clientWidth / rendererContainer.clientHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(rendererContainer.clientWidth, rendererContainer.clientHeight);
            
            // Light
            const light = new THREE.DirectionalLight(0xffffff, 3);
            light.position.set(5, 10, 7.5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040, 3));

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            // Position camera
            camera.position.set(width * 0.7, height * 0.7, depth * 0.7);
            camera.lookAt(width / 2, height / 2, depth / 2);
            controls.target.set(width / 2, height / 2, depth / 2);
            controls.update();

            is3DInitialized = true;
            update3DView();
            animate();
        }

        function update3DView() {
            voxelMeshes.forEach(mesh => scene.remove(mesh));
            voxelMeshes = [];
            const boxGeometry = new THREE.BoxGeometry(1, 1, 1);

            for (let y = 0; y < height; y++) {
                for (let z = 0; z < depth; z++) {
                    for (let x = 0; x < width; x++) {
                        const color = voxelData[y][z][x];
                        if (color) {
                            const material = new THREE.MeshLambertMaterial({ color: color });
                            const mesh = new THREE.Mesh(boxGeometry, material);
                            
                            // THREE.js座標系: X:幅, Y:高さ, Z:奥行き
                            // VoxelEditor座標系: X:幅, Y:高さ, Z:グリッド奥行き
                            mesh.position.set(
                                x + 0.5, 
                                y + 0.5, 
                                z + 0.5
                            );
                            voxelMeshes.push(mesh);
                            scene.add(mesh);
                        }
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            if (renderer) renderer.render(scene, camera);
        }
        
        // --- エクスポート/インポート ---

        function saveJSON() {
            const data = {
                width,
                height,
                depth,
                voxelData: voxelData
            };
            const json = JSON.stringify(data);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'voxel_model.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadData(data) {
            saveStateForUndo();
            width = data.width;
            height = data.height;
            depth = data.depth;
            voxelData = data.voxelData;
            currentLayer = 0; 
            document.getElementById('inputWidth').value = width;
            document.getElementById('inputHeight').value = height;
            document.getElementById('inputDepth').value = depth;
            
            initGrid();
            updateLayerLabel();
            updateGridColors();
            if (is3DInitialized) update3DView();
        }

        // OBJエクスポートのロジック (省略せず記述)
        function saveOBJ() {
            let obj = '';
            let vCount = 1;
            const vertices = [];
            const normals = [
                "0 0 1", "0 0 -1", // Z+ Z-
                "1 0 0", "-1 0 0", // X+ X-
                "0 1 0", "0 -1 0"  // Y+ Y-
            ];
            
            normals.forEach((n, i) => obj += `vn ${n}\n`);
            
            for (let y = 0; y < height; y++) {
                for (let z = 0; z < depth; z++) {
                    for (let x = 0; x < width; x++) {
                        if (voxelData[y][z][x]) {
                            const X = x, Y = y, Z = z;
                            const color = voxelData[y][z][x];
                            // 頂点
                            const v = [
                                [X, Y, Z], [X+1, Y, Z], [X+1, Y+1, Z], [X, Y+1, Z], // Z- (Back)
                                [X, Y, Z+1], [X+1, Y, Z+1], [X+1, Y+1, Z+1], [X, Y+1, Z+1]  // Z+ (Front)
                            ];
                            v.forEach(vert => vertices.push(vert));
                            
                            // 面 (UVは省略)
                            const f = (n, vs) => {
                                let face = `f`;
                                vs.forEach(vIndex => {
                                    face += ` ${vIndex}/${vIndex}/${n}`;
                                });
                                return face;
                            };
                            
                            // Z+ (Front) - vn 1
                            obj += f(1, [vCount+4, vCount+5, vCount+6, vCount+7]) + `\n`; 
                            // Z- (Back) - vn 2
                            obj += f(2, [vCount+3, vCount+2, vCount+1, vCount]) + `\n`; 
                            // X+ (Right) - vn 3
                            obj += f(3, [vCount+1, vCount+5, vCount+6, vCount+2]) + `\n`; 
                            // X- (Left) - vn 4
                            obj += f(4, [vCount+4, vCount, vCount+3, vCount+7]) + `\n`; 
                            // Y+ (Top) - vn 5
                            obj += f(5, [vCount+3, vCount+2, vCount+6, vCount+7]) + `\n`; 
                            // Y- (Bottom) - vn 6
                            obj += f(6, [vCount+4, vCount+5, vCount+1, vCount]) + `\n`; 

                            vCount += 8;
                        }
                    }
                }
            }
            
            let objFile = `# Voxel Model Export\n`;
            vertices.forEach(([x, y, z]) => objFile += `v ${x} ${y} ${z}\n`);
            objFile += obj;
            
            const blob = new Blob([objFile], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'voxel_model.obj';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- 画像処理 (要望①のオフセット統合) ---

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    renderImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function renderImage(img) {
            if (overlayImage) {
                overlayImage.remove();
            }
            overlayImage = img;
            overlayImage.classList.add('overlay-image');
            gridWrapper.appendChild(overlayImage);
            handleImageResize();
        }

        function handleImageResize() {
            if (!overlayImage) return;
            const w = parseInt(imgWidthInput.value);
            const h = parseInt(imgHeightInput.value);
            overlayImage.style.width = `${w}px`;
            overlayImage.style.height = `${h}px`;
        }

        function convertImageTo3d(side) {
            const img = overlayImage;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const imageW = parseInt(imgWidthInput.value);
            const imageH = parseInt(imgHeightInput.value);
            
            canvas.width = imageW;
            canvas.height = imageH;
            ctx.drawImage(img, 0, 0, imageW, imageH);
            
            const imageData = ctx.getImageData(0, 0, imageW, imageH);
            const data = imageData.data;

            // 変換先のグリッドの縦横のサイズ
            let gridW, gridD;
            if (side === 'front' || side === 'back') {
                gridW = width;
                gridD = height;
            } else if (side === 'left' || side === 'right') {
                gridW = depth;
                gridD = height;
            } else { // top || bottom
                gridW = width;
                gridD = depth;
            }

            const scaleX = imageW / gridW;
            const scaleY = imageH / gridD;

            // オフセット値の取得 (要望①)
            const offsetX = parseInt(imgOffsetXInput.value) || 0;
            const offsetY = parseInt(imgOffsetYInput.value) || 0;

            saveStateForUndo();
            
            for (let y = 0; y < gridD; y++) {
                for (let x = 0; x < gridW; x++) {
                    
                    // グリッド座標にオフセットを適用
                    const targetX = x + offsetX;
                    const targetY = y + offsetY;

                    if (targetX < 0 || targetX >= gridW || targetY < 0 || targetY >= gridD) continue;

                    // 画像上の対応するピクセル座標
                    const pixelX = Math.floor(x * scaleX);
                    const pixelY = Math.floor(y * scaleY);

                    const index = (pixelY * imageW + pixelX) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    const a = data[index + 3];
                    
                    if (a > 128) {
                        const hexColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                        
                        let voxelX, voxelY, voxelZ;

                        if (side === 'front') {
                            voxelX = targetX;
                            voxelY = height - 1 - targetY; // 画面上部がY座標大 (上向き)
                            voxelZ = depth - 1;
                        } else if (side === 'back') {
                            voxelX = targetX;
                            voxelY = height - 1 - targetY;
                            voxelZ = 0;
                        } else if (side === 'left') {
                            voxelX = 0;
                            voxelY = height - 1 - targetY;
                            voxelZ = targetX; // グリッドのX軸が奥行きZになる
                        } else if (side === 'right') {
                            voxelX = width - 1;
                            voxelY = height - 1 - targetY;
                            voxelZ = targetX;
                        } else if (side === 'top') {
                            voxelX = targetX;
                            voxelY = height - 1;
                            voxelZ = targetY; // グリッドのY軸が奥行きZになる
                        } else if (side === 'bottom') {
                            voxelX = targetX;
                            voxelY = 0;
                            voxelZ = targetY;
                        }
                        
                        if (voxelX >= 0 && voxelX < width && voxelY >= 0 && voxelY < height && voxelZ >= 0 && voxelZ < depth) {
                            voxelData[voxelY][voxelZ][voxelX] = hexColor;
                        }
                    }
                }
            }
            
            updateGridColors();
            if (is3DInitialized) update3DView();
        }

        // --- イベントハンドラ (既存) ---

        document.getElementById('colorPicker').addEventListener('input', (e) => {
            drawColor = e.target.value;
        });

        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        document.getElementById('resizeBtn').addEventListener('click', () => {
            saveStateForUndo();
            const newWidth = parseInt(document.getElementById('inputWidth').value);
            const newHeight = parseInt(document.getElementById('inputHeight').value);
            const newDepth = parseInt(document.getElementById('inputDepth').value);
            resizeData(newWidth, newHeight, newDepth);
        });

        document.getElementById('layerPrevBtn').addEventListener('click', () => {
            currentLayer = Math.max(0, currentLayer - 1);
            updateLayerLabel();
            updateGridColors();
        });

        document.getElementById('layerNextBtn').addEventListener('click', () => {
            currentLayer = Math.min(height - 1, currentLayer + 1);
            updateLayerLabel();
            updateGridColors();
        });

        document.getElementById('show3dBtn').addEventListener('click', () => {
            gridContainer.style.display = 'none';
            rendererContainer.style.display = 'block';
            if (!is3DInitialized) {
                init3DView();
            } else {
                update3DView();
            }
        });

        document.getElementById('show2dBtn').addEventListener('click', () => {
            rendererContainer.style.display = 'none';
            gridContainer.style.display = 'block';
            updateGridColors();
        });

        document.getElementById('saveJsonBtn').addEventListener('click', saveJSON);
        document.getElementById('saveObjBtn').addEventListener('click', saveOBJ);
        document.getElementById('undoBtn').addEventListener('click', undo);
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            // <--- FIX 3: リセット時の警告表示
            if (!confirm("現在の作業内容をすべてリセットしてもよろしいですか？この操作は元に戻せません。")) {
                return;
            }
            saveStateForUndo();
            initData();
            updateGridColors();
            if (is3DInitialized) update3DView();
        });
        
        imageInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadImage(e.target.files[0]);
            }
        });

        applyImageSizeBtn.addEventListener('click', handleImageResize);

        deleteImageBtn.addEventListener('click', () => {
            if (overlayImage) {
                overlayImage.remove();
                overlayImage = null;
                toggleMoveImageBtn.textContent = '画像移動モード: OFF';
                isImageMoveMode = false;
            }
        });

        convertImageTo3dBtn.addEventListener('click', () => {
            if (!overlayImage) {
                alert('先に画像をインポートしてください。');
                return;
            }
            sideSelectionDiv.style.display = 'block';
        });

        sideSelectionDiv.addEventListener('click', (e) => {
            const side = e.target.dataset.side;
            if (side) {
                sideSelectionDiv.style.display = 'none';
                if (side === 'cancel') return;
                
                convertImageTo3d(side);
            }
        });

        document.getElementById('importJsonInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    loadData(data);
                } catch (error) {
                    alert('JSONファイルの読み込みに失敗しました。');
                    console.error(error);
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('copyLayerAddBtn').addEventListener('click', () => {
            saveStateForUndo();
            const newLayerData = JSON.parse(JSON.stringify(voxelData[currentLayer]));
            voxelData.push(newLayerData);
            height++;
            currentLayer++;
            document.getElementById('inputHeight').value = height;
            updateLayerLabel();
            updateGridColors();
            if (is3DInitialized) update3DView();
        });

        window.addEventListener('resize', () => {
            if (is3DInitialized) {
                renderer.setSize(rendererContainer.clientWidth, rendererContainer.clientHeight);
                camera.aspect = rendererContainer.clientWidth / rendererContainer.clientHeight;
                camera.updateProjectionMatrix();
            }
        });
        
        // --- 初期化 ---
        initData();
        updateLayerLabel();
        initGrid();
        updateGridColors();
        setMode('draw');
    </script>
</body>
</html>
