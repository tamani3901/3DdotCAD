<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>Voxelエディタ with 画像機能フル版 + 図形/コピー機能</title>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
            background-color: #222;
            color: #fff;
            overscroll-behavior: none;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            background: #333;
        }
        #top-controls {
            display:flex;
            gap:10px;
            align-items:center;
            flex-wrap:wrap;
        }
        #tab-buttons { display:flex; gap:5px; flex-wrap:wrap; }
        .tab-content { display:none; gap:10px; padding:5px 0; align-items:center; }
        .tab-content.active { display:flex; }
        button, input[type="color"], input[type="number"], input[type="range"], label.custom-file-label {
            padding:5px;
            font-size:14px;
            border:none;
            border-radius:4px;
            background-color:#444;
            color:#fff;
            cursor:pointer;
        }
        button:hover, label.custom-file-label:hover { background-color:#666; }
        .tab-button.active { background-color:#007bff; }
        #grid-container {
            width: 80vw;
            height: 70vh;
            overflow: auto;
            border: 2px solid #444;
            margin: 10px;
            position: relative;
        }
        #grid-wrapper { position: relative; }
        #grid { position: relative; z-index: 20; display: grid; touch-action: none; background: transparent; }
        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #555;
            box-sizing: border-box;
            position: relative;
        }
        .cell-highlight {
            position: absolute;
            top: 0; left: 0; width:100%; height:100%;
            background-color: rgba(255,255,255,0.12);
            pointer-events: none;
        }
        #selection-box {
            position: absolute;
            background-color: rgba(0, 100, 255, 0.2);
            border: 1px dashed rgba(255,255,255,0.8);
            pointer-events: none;
            z-index: 50;
        }
        .selecting-cell, .selected-cell { opacity: 0.9; border: 1px solid rgba(255,255,255,0.8) !important; }
        .moving-box { background-color: rgba(255,255,255,0.08) !important; border: 2px dashed rgba(255,255,255,0.8) !important; }
        #renderer-container { display: none; width: 80vw; height: 70vh; margin: 10px; border: 2px solid #444; }
        canvas { width:100%; height:100%; display:block; }
        #scrollButtons { position: fixed; bottom: 20px; right: 20px; display:flex; flex-direction:column; gap:5px; z-index:1000; }
        .overlay-image { position:absolute; opacity:0.3; pointer-events:none; z-index:1; user-select:none; }
        .overlay-image.moving { opacity:0.85; pointer-events:auto; z-index:25; cursor:move; }
        .custom-file-label { display:inline-block; }
        #shapeControls { display:flex; gap:6px; align-items:center; }
        #shapeControls button { min-width:36px; }
    </style>
</head>
<body>
    <div id="controls">
        <div id="top-controls">
            <div id="tab-buttons">
                <button class="tab-button active" data-tab="drawTab">描画</button>
                <button class="tab-button" data-tab="selectMoveTab">選択移動</button>
                <button class="tab-button" data-tab="insertTab">挿入</button>
                <button class="tab-button" data-tab="convertTab">変換</button>
                <button class="tab-button" data-tab="exportTab">エクスポート</button>
            </div>

            <button id="show2dBtn">2D表示</button>
            <button id="show3dBtn">3D表示</button>

            <input type="number" id="inputWidth" value="16" min="1" max="128" />×
            <input type="number" id="inputHeight" value="16" min="1" max="128" />×
            <input type="number" id="inputDepth" value="16" min="1" max="128" />
            <button id="resizeBtn">サイズ変更</button>

            <button id="layerPrevBtn">↑</button>
            <button id="layerNextBtn">↓</button>
            <span id="layerLabel"></span>
        </div>

        <div id="drawTab" class="tab-content active">
            <input type="color" id="colorPicker" value="#ff0000" />
            <button id="drawBtn">描画</button>
            <button id="eraseBtn">消去</button>
            <input type="range" id="brushSize" min="1" max="5" value="1" />
            <span id="brushSizeValue">1</span>

            <!-- 追加: 図形プリセット -->
            <button id="circleBtn">円</button>
            <button id="rectBtn">四角</button>
            <button id="triBtn">三角</button>
            <div id="shapeControls" style="display:none;">
                <button id="shapeMoveBtn">移動</button>
                <button id="shapeDecBtn">－</button>
                <span id="shapeSizeLabel">5</span>
                <button id="shapeIncBtn">＋</button>
                <button id="shapeRotateBtn">回転</button>
                <button id="shapePlaceBtn">配置</button>
                <button id="shapeCancelBtn">キャンセル</button>
            </div>
        </div>

        <div id="selectMoveTab" class="tab-content">
            <button id="selectBtn">選択</button>
            <button id="completeSelectionBtn" style="display:none;">選択完了</button>
            <button id="cancelSelectionBtn" style="display:none;">キャンセル</button>

            <!-- 追加: コピー/カット/ペースト -->
            <button id="copyBtn">コピー</button>
            <button id="cutBtn">カット</button>
            <button id="pasteBtn">ペースト</button>
            <button id="flipHorizBtn">水平反転</button>
            <button id="flipVertBtn">垂直反転</button>
        </div>

        <div id="insertTab" class="tab-content">
            <input type="file" id="importJsonInput" accept=".json" style="display:none;" />
            <label for="importJsonInput" class="custom-file-label">JSONインポート</label>
            <input type="file" id="imageInput" accept="image/*" style="display:none;" />
            <label for="imageInput" class="custom-file-label">画像インポート</label>
        </div>

        <div id="convertTab" class="tab-content">
            <button id="convertImageTo3dBtn">画像→3D変換</button>
            <input type="number" id="imgWidth" value="100" style="width: 60px;" />×
            <input type="number" id="imgHeight" value="100" style="width: 60px;" />
            <button id="applyImageSize">画像サイズ変更</button>
            <button id="toggleMoveImage">画像移動モード: OFF</button>
            <button id="deleteImageBtn">画像削除</button>
            <div style="font-size:12px; margin-left:8px;">※画像を面に配置するときは「画像移動モード」をONにして指でスライド</div>
        </div>

        <div id="exportTab" class="tab-content">
            <button id="saveObjBtn">OBJエクスポート</button>
            <button id="saveJsonBtn">JSONエクスポート</button>
            <button id="save3dImageBtn">スクショ</button>
            <button id="undoBtn">元に戻す</button>
            <button id="resetBtn">リセット</button>
        </div>
    </div>

    <div id="grid-container">
        <div id="grid-wrapper">
            <div id="grid"></div>
            <div id="selection-box" style="display:none;"></div>
        </div>
    </div>

    <div id="renderer-container">
        <canvas id="threejs-canvas"></canvas>
    </div>

    <div id="sideSelection" style="display:none; position: fixed; top:50%; left:50%; transform:translate(-50%,-50%); padding:16px; background:#444; border-radius:8px; z-index:1002;">
        <p style="margin:0 0 8px 0;">どの面に画像を配置しますか？</p>
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button data-side="front">前面</button>
            <button data-side="back">背面</button>
            <button data-side="left">左面</button>
            <button data-side="right">右面</button>
            <button data-side="top">上面</button>
            <button data-side="bottom">下面</button>
        </div>
        <div style="margin-top:8px;"><button id="cancelBtn">キャンセル</button></div>
    </div>

    <div id="scrollButtons">
        <button id="scrollUp">↑</button>
        <button id="scrollDown">↓</button>
        <button id="scrollLeft">←</button>
        <button id="scrollRight">→</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 基本データ ---
    let width = 16, height = 16, depth = 16;
    let currentLayer = 0;
    let drawColor = "#ff0000";
    let isErasing = false;
    let brushSize = 1;
    let voxelData = [];
    let scene, camera, renderer, controls;
    let is3DInitialized = false;
    let voxelMeshes = [];
    let undoStack = [];

    // DOM
    const grid = document.getElementById("grid");
    const gridWrapper = document.getElementById("grid-wrapper");
    const layerLabel = document.getElementById("layerLabel");
    const imageInput = document.getElementById('imageInput');
    const imgWidthInput = document.getElementById('imgWidth');
    const imgHeightInput = document.getElementById('imgHeight');
    const applyImageSizeBtn = document.getElementById('applyImageSize');
    const toggleMoveImageBtn = document.getElementById('toggleMoveImage');
    const deleteImageBtn = document.getElementById('deleteImageBtn');
    const convertImageTo3dBtn = document.getElementById('convertImageTo3dBtn');
    const sideSelectionDiv = document.getElementById('sideSelection');
    const cancelBtn = document.getElementById('cancelBtn');
    const selectionBox = document.getElementById('selection-box');

    // 状態
    let cells = []; // 2Dセル DOM配列 [z][x]
    let overlayImage = null;
    let isImageMoveMode = false;
    let draggingImage = false;
    let dragStartX = 0, dragStartY = 0, imgStartLeft = 0, imgStartTop = 0;

    // 選択関連
    let currentMode = 'draw'; // draw, erase, select, move
    let isDrawing = false;
    let isSelecting = false;
    let isMoving = false;
    let selectStartX=0, selectStartZ=0;
    let selectedCells = []; // {x,z,color}
    let selectedVoxelData = []; // relative data for paste/move
    let movingStartMouseX=0, movingStartMouseY=0, movingStartGridX=0, movingStartGridZ=0;

    // 図形プリセット
    let shapeMode = null; // null | 'circle'|'rect'|'tri'
    let shapeSize = 5;
    let shapeAngle = 0; // 0/90/180/270
    let shapeX = 0, shapeZ = 0;
    const shapeSizeLabel = document.getElementById('shapeSizeLabel');
    const shapeControlsDiv = document.getElementById('shapeControls');

    // クリップボード
    let clipboard = []; // {x,z,color} relative to origin (0,0)

    // --- タブ切替 ---
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');
    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            button.classList.add('active');
            const targetTab = document.getElementById(button.dataset.tab);
            if (targetTab) targetTab.classList.add('active');
            if (button.dataset.tab === 'drawTab') setMode('draw');
            else if (button.dataset.tab === 'selectMoveTab') setMode('select');
            else setMode('none');
        });
    });

    function setMode(mode) {
        currentMode = mode;
        document.getElementById('completeSelectionBtn').style.display = (mode==='select' || mode==='move') ? 'inline-block' : 'none';
        document.getElementById('cancelSelectionBtn').style.display = (mode==='select' || mode==='move') ? 'inline-block' : 'none';
        if (mode !== 'select' && mode !== 'move') clearSelection();
    }

    function clearSelection() {
        selectedCells = [];
        selectedVoxelData = [];
        isSelecting = false;
        isMoving = false;
        selectionBox.style.display = 'none';
        selectionBox.classList.remove('moving-box');
        cells.flat().forEach(cell => cell.classList.remove('selecting-cell','selected-cell'));
        renderGridColors();
    }

    // --- 初期化データ/グリッド ---
    function initData() {
        voxelData = Array.from({ length: height }, () =>
            Array.from({ length: depth }, () =>
                Array.from({ length: width }, () => null)
            )
        );
    }
    function initGrid() {
        grid.innerHTML = "";
        cells = [];
        grid.style.gridTemplateColumns = `repeat(${width}, 20px)`;
        grid.style.gridTemplateRows = `repeat(${depth}, 20px)`;
        for (let z = 0; z < depth; z++) {
            const row = [];
            for (let x = 0; x < width; x++) {
                const cell = document.createElement("div");
                cell.className = "cell";
                cell.dataset.x = x;
                cell.dataset.z = z;
                const highlight = document.createElement("div");
                highlight.className = "cell-highlight";
                highlight.style.display = "none";
                cell.appendChild(highlight);
                cell.addEventListener("mouseenter", () => { highlight.style.display = "block"; });
                cell.addEventListener("mouseleave", () => { highlight.style.display = "none"; });
                grid.appendChild(cell);
                row.push(cell);
            }
            cells.push(row);
        }
    }
    function updateLayerLabel() {
        layerLabel.textContent = `レイヤー: ${currentLayer+1} / ${height}`;
    }

    // --- 描画/消去 ---
    function saveStateForUndo() {
        const clone = voxelData.map(layer => layer.map(row => row.slice()));
        undoStack.push(clone);
        if (undoStack.length > 30) undoStack.shift();
    }
    function undo() {
        if (undoStack.length === 0) return;
        voxelData = undoStack.pop();
        if (currentLayer >= height) currentLayer = height - 1;
        renderGrid();
        if (is3DInitialized) update3DView();
    }
    function paintCells(centerX, centerZ) {
        saveStateForUndo();
        const halfSize = Math.floor(brushSize / 2);
        for (let zOffset = -halfSize; zOffset <= halfSize; zOffset++) {
            for (let xOffset = -halfSize; xOffset <= halfSize; xOffset++) {
                const x = centerX + xOffset;
                const z = centerZ + zOffset;
                if (x >= 0 && x < width && z >= 0 && z < depth) {
                    voxelData[currentLayer][z][x] = isErasing ? null : drawColor;
                }
            }
        }
        renderGrid();
        if (is3DInitialized && document.getElementById('renderer-container').style.display === 'block') update3DView();
    }

    // --- レンダリング（2Dセル更新） ---
    function renderGrid() {
        if (cells.length === 0 || cells.length !== depth || (cells[0] && cells[0].length !== width)) initGrid();
        for (let z = 0; z < depth; z++) {
            for (let x = 0; x < width; x++) {
                const cell = cells[z][x];
                const color = voxelData[currentLayer][z][x];
                cell.style.backgroundColor = color ?? "transparent";
                cell.classList.toggle('selected-cell', selectedCells.some(c => c.x === x && c.z === z));
            }
        }
        updateImagePositionAndLayer();
        // 図形プレビュー
        if (shapeMode) {
            const pts = getShapeCoordsPreview();
            pts.forEach(p => {
                if (p.x>=0 && p.x<width && p.z>=0 && p.z<depth) {
                    const cell = cells[p.z][p.x];
                    cell.style.backgroundColor = cell.style.backgroundColor || 'rgba(255,255,255,0.25)';
                }
            });
        }
    }

    // --- 選択ボックス / マウス操作 ---
    document.getElementById("grid").addEventListener('mousedown', (e) => {
        const cell = e.target.closest('.cell');
        if (!cell) return;
        const x = parseInt(cell.dataset.x), z = parseInt(cell.dataset.z);
        if (currentMode === 'draw' || currentMode === 'erase') {
            isDrawing = true; paintCells(x,z);
        } else if (currentMode === 'select') {
            isSelecting = true;
            selectStartX = x; selectStartZ = z;
            selectionBox.style.display = 'block';
            selectionBox.classList.remove('moving-box');
            selectionBox.style.left = `${x * 20}px`;
            selectionBox.style.top = `${z * 20}px`;
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            cells.flat().forEach(c=>c.classList.remove('selecting-cell'));
        } else if (currentMode === 'move') {
            // 判定：選択内のセルをクリックしたか
            const idx = selectedCells.findIndex(c => c.x === x && c.z === z);
            if (idx !== -1) {
                isMoving = true;
                saveStateForUndo();
                movingStartMouseX = e.clientX; movingStartMouseY = e.clientY;
                movingStartGridX = parseInt(selectionBox.style.left) / 20;
                movingStartGridZ = parseInt(selectionBox.style.top) / 20;
            } else {
                clearSelection();
            }
        }
    });
    window.addEventListener('mousemove', (e) => {
        if (isDrawing && (currentMode==='draw' || currentMode==='erase')) {
            const el = document.elementFromPoint(e.clientX, e.clientY);
            if (el && el.classList && el.classList.contains('cell')) {
                const x = parseInt(el.dataset.x), z = parseInt(el.dataset.z);
                paintCells(x,z);
            }
        } else if (isSelecting && currentMode==='select') {
            const el = document.elementFromPoint(e.clientX, e.clientY);
            if (!el || !el.classList.contains('cell')) return;
            const endX = parseInt(el.dataset.x), endZ = parseInt(el.dataset.z);
            const minX = Math.min(selectStartX, endX), maxX = Math.max(selectStartX,endX);
            const minZ = Math.min(selectStartZ, endZ), maxZ = Math.max(selectStartZ,endZ);
            selectionBox.style.left = `${minX*20}px`;
            selectionBox.style.top = `${minZ*20}px`;
            selectionBox.style.width = `${(maxX-minX+1)*20}px`;
            selectionBox.style.height = `${(maxZ-minZ+1)*20}px`;
            cells.flat().forEach(c=>c.classList.remove('selecting-cell'));
            for (let zz=minZ; zz<=maxZ; zz++) for (let xx=minX; xx<=maxX; xx++) cells[zz][xx].classList.add('selecting-cell');
        } else if (isMoving && currentMode==='move') {
            const dx = Math.round((e.clientX - movingStartMouseX)/20);
            const dy = Math.round((e.clientY - movingStartMouseY)/20);
            const newX = movingStartGridX + dx, newZ = movingStartGridZ + dy;
            selectionBox.style.left = `${newX*20}px`;
            selectionBox.style.top = `${newZ*20}px`;
        }
    });
    window.addEventListener('mouseup', (e) => {
        isDrawing = false;
        if (isMoving) {
            const dx = Math.round((e.clientX - movingStartMouseX)/20);
            const dy = Math.round((e.clientY - movingStartMouseY)/20);
            moveSelectedCells(dx,dy);
            isMoving = false;
        }
    });

    // touch events (スマホ操作)
    grid.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        const cell = getCellFromPoint(touch.clientX, touch.clientY);
        if (!cell) return;
        const x = parseInt(cell.dataset.x), z = parseInt(cell.dataset.z);
        if (currentMode === 'draw' || currentMode === 'erase') { isDrawing = true; paintCells(x,z); }
        else if (currentMode === 'select') {
            isSelecting = true; selectStartX = x; selectStartZ = z;
            selectionBox.style.display = 'block';
            selectionBox.classList.remove('moving-box');
            selectionBox.style.left = `${x * 20}px`;
            selectionBox.style.top = `${z * 20}px`;
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            cells.flat().forEach(c=>c.classList.remove('selecting-cell'));
        }
    }, {passive:false});
    grid.addEventListener('touchmove', (e) => {
        if (isDrawing && (currentMode==='draw'||currentMode==='erase')) {
            const touch = e.touches[0];
            const el = document.elementFromPoint(touch.clientX, touch.clientY);
            if (el && el.classList && el.classList.contains('cell')) paintCells(parseInt(el.dataset.x), parseInt(el.dataset.z));
        } else if (isSelecting && currentMode==='select') {
            const touch = e.touches[0];
            const cell = getCellFromPoint(touch.clientX, touch.clientY);
            if (!cell) return;
            const endX = parseInt(cell.dataset.x), endZ = parseInt(cell.dataset.z);
            const minX = Math.min(selectStartX, endX), maxX = Math.max(selectStartX,endX);
            const minZ = Math.min(selectStartZ, endZ), maxZ = Math.max(selectStartZ,endZ);
            selectionBox.style.left = `${minX*20}px`; selectionBox.style.top = `${minZ*20}px`;
            selectionBox.style.width = `${(maxX-minX+1)*20}px`; selectionBox.style.height = `${(maxZ-minZ+1)*20}px`;
            cells.flat().forEach(c=>c.classList.remove('selecting-cell'));
            for (let zz=minZ; zz<=maxZ; zz++) for (let xx=minX; xx<=maxX; xx++) cells[zz][xx].classList.add('selecting-cell');
        }
    }, {passive:false});
    window.addEventListener('touchend', (e) => {
        isDrawing = false;
        if (isMoving) {
            const touch = e.changedTouches[0];
            const dx = Math.round((touch.clientX - movingStartMouseX)/20);
            const dy = Math.round((touch.clientY - movingStartMouseY)/20);
            moveSelectedCells(dx,dy);
            isMoving = false;
        }
    });

    function getCellFromPoint(clientX, clientY) {
        const rect = grid.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const cellX = Math.floor(x / 20);
        const cellZ = Math.floor(y / 20);
        if (cellX >= 0 && cellX < width && cellZ >= 0 && cellZ < depth) return cells[cellZ][cellX];
        return null;
    }

    // --- 選択確定処理（選択完了ボタン） ---
    document.getElementById('completeSelectionBtn').addEventListener('click', () => {
        if (isSelecting) {
            isSelecting = false;
            // 算出
            const rect = selectionBox.getBoundingClientRect();
            const gridRect = grid.getBoundingClientRect();
            const startX = Math.round((rect.left - gridRect.left) / 20);
            const startZ = Math.round((rect.top - gridRect.top) / 20);
            const endX = startX + Math.round(rect.width / 20) - 1;
            const endZ = startZ + Math.round(rect.height / 20) - 1;
            selectedCells = [];
            selectedVoxelData = [];
            for (let z = startZ; z <= endZ; z++) {
                for (let x = startX; x <= endX; x++) {
                    const color = voxelData[currentLayer][z][x];
                    if (color) {
                        selectedCells.push({ x, z, color });
                        selectedVoxelData.push({ x: x - startX, z: z - startZ, color });
                    }
                }
            }
            // 切り取り（選択完了時は既定で切り取らない。カットボタンで切る）
            // ただし UI要望で「選択完了後も半透明表示で裏の書いてあるものが見えるように」
            // -> 選択領域は半透明で表示: selectionBoxは表示中、選択セルは selected-cell クラス付与
            selectionBox.style.display = 'block';
            selectionBox.classList.add('moving-box');
            setMode('move');
            renderGrid();
            return;
        }
        if (currentMode === 'move' && selectedCells.length > 0) {
            // move-> select 後処理（もう一度押すと解除）
            clearSelection();
            setMode('select');
        }
    });

    document.getElementById('selectBtn').addEventListener('click', () => { setMode('select'); clearSelection(); });
    document.getElementById('cancelSelectionBtn').addEventListener('click', () => { clearSelection(); setMode('select'); });

    // 選択を移動して確定
    function moveSelectedCells(dx, dy) {
        if (selectedVoxelData.length === 0) return;
        const newCells = [];
        for (const voxel of selectedVoxelData) {
            const newX = movingStartGridX + voxel.x + dx;
            const newZ = movingStartGridZ + voxel.z + dy;
            if (newX >= 0 && newX < width && newZ >= 0 && newZ < depth) {
                voxelData[currentLayer][newZ][newX] = voxel.color;
                newCells.push({x:newX,z:newZ,color:voxel.color});
            }
        }
        selectedCells = newCells;
        // 選択を現在のselectionBox位置に合わせる
        selectionBox.style.left = `${(movingStartGridX + dx) * 20}px`;
        selectionBox.style.top = `${(movingStartGridZ + dy) * 20}px`;
        renderGrid();
        if (is3DInitialized) update3DView();
    }

    // --- コピー / カット / ペースト 実装 ---
    document.getElementById('copyBtn').addEventListener('click', () => {
        if (!selectedVoxelData.length) return alert('何も選択されてないよ');
        // clipboard は相対座標（左上が0,0）
        clipboard = selectedVoxelData.map(v => ({ x:v.x, z:v.z, color:v.color }));
        alert('コピーしたよ');
    });
    document.getElementById('cutBtn').addEventListener('click', () => {
        if (!selectedCells.length) return alert('何も選択されてないよ');
        clipboard = selectedVoxelData.map(v => ({ x:v.x, z:v.z, color:v.color }));
        // 元を消す（カット）
        const rect = selectionBox.getBoundingClientRect();
        const gridRect = grid.getBoundingClientRect();
        const startX = Math.round((rect.left - gridRect.left) / 20);
        const startZ = Math.round((rect.top - gridRect.top) / 20);
        for (let v of clipboard) {
            const gx = startX + v.x, gz = startZ + v.z;
            if (gx>=0&&gx<width&&gz>=0&&gz<depth) voxelData[currentLayer][gz][gx] = null;
        }
        clearSelection();
        renderGrid();
        alert('カットしたよ');
    });
    document.getElementById('pasteBtn').addEventListener('click', () => {
        if (!clipboard.length) return alert('クリップボードに何も無いよ');
        // 貼る基準をselectionBoxの左上（存在しなければ0,0）
        let baseX=0, baseZ=0;
        if (selectionBox.style.display !== 'none') {
            const rect = selectionBox.getBoundingClientRect();
            const gridRect = grid.getBoundingClientRect();
            baseX = Math.round((rect.left - gridRect.left) / 20);
            baseZ = Math.round((rect.top - gridRect.top) / 20);
        } else {
            // 何も選んでない場合、左上0,0を使うか、canvas中央に置くか。ここでは左上
            baseX = 0; baseZ = 0;
        }
        saveStateForUndo();
        // 1セル右下にずらしてペースト（元の動作を踏襲する場合＋1）
        for (const v of clipboard) {
            const gx = baseX + v.x, gz = baseZ + v.z;
            if (gx>=0&&gx<width&&gz>=0&&gz<depth) voxelData[currentLayer][gz][gx] = v.color;
        }
        renderGrid();
        if (is3DInitialized) update3DView();
    });

    // 追加: 水平/垂直反転（便利）
    document.getElementById('flipHorizBtn').addEventListener('click', () => {
        if (!selectedVoxelData.length) return alert('先に選択してね');
        // clipboard に入れて反転して戻す
        let maxX = Math.max(...selectedVoxelData.map(v=>v.x));
        const flipped = selectedVoxelData.map(v=>({ x: maxX - v.x, z: v.z, color: v.color }));
        // 書き込み：現在selectionBoxの左上を基準に
        const rect = selectionBox.getBoundingClientRect();
        const gridRect = grid.getBoundingClientRect();
        const baseX = Math.round((rect.left - gridRect.left)/20);
        const baseZ = Math.round((rect.top - gridRect.top)/20);
        saveStateForUndo();
        // まず選択領域内をクリア
        // (そうしないと重ねる)
        for (let v of selectedVoxelData) {
            const gx = baseX + v.x, gz = baseZ + v.z;
            if (gx>=0&&gx<width&&gz>=0&&gz<depth) voxelData[currentLayer][gz][gx] = null;
        }
        for (let v of flipped) {
            const gx = baseX + v.x, gz = baseZ + v.z;
            if (gx>=0&&gx<width&&gz>=0&&gz<depth) voxelData[currentLayer][gz][gx] = v.color;
        }
        clearSelection(); renderGrid();
    });
    document.getElementById('flipVertBtn').addEventListener('click', () => {
        if (!selectedVoxelData.length) return alert('先に選択してね');
        let maxZ = Math.max(...selectedVoxelData.map(v=>v.z));
        const flipped = selectedVoxelData.map(v=>({ x: v.x, z: maxZ - v.z, color: v.color }));
        const rect = selectionBox.getBoundingClientRect();
        const gridRect = grid.getBoundingClientRect();
        const baseX = Math.round((rect.left - gridRect.left)/20);
        const baseZ = Math.round((rect.top - gridRect.top)/20);
        saveStateForUndo();
        for (let v of selectedVoxelData) {
            const gx = baseX + v.x, gz = baseZ + v.z;
            if (gx>=0&&gx<width&&gz>=0&&gz<depth) voxelData[currentLayer][gz][gx] = null;
        }
        for (let v of flipped) {
            const gx = baseX + v.x, gz = baseZ + v.z;
            if (gx>=0&&gx<width&&gz>=0&&gz<depth) voxelData[currentLayer][gz][gx] = v.color;
        }
        clearSelection(); renderGrid();
    });

    // --- 画像インポート / 移動 / 面配置 ---
    imageInput.addEventListener('change', (e) => {
        if (!e.target.files || e.target.files.length === 0) return;
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = () => {
            if (overlayImage) { overlayImage.remove(); overlayImage = null; }
            overlayImage = document.createElement('img');
            overlayImage.src = reader.result;
            overlayImage.className = 'overlay-image';
            overlayImage.style.width = imgWidthInput.value + 'px';
            overlayImage.style.height = imgHeightInput.value + 'px';
            overlayImage.style.left = '0px';
            overlayImage.style.top = '0px';
            overlayImage.style.zIndex = 1;
            gridWrapper.appendChild(overlayImage);
            updateImagePositionAndLayer();
        };
        reader.readAsDataURL(file);
        imageInput.value = '';
    });

    applyImageSizeBtn.addEventListener('click', () => {
        if (!overlayImage) return;
        let w = parseInt(imgWidthInput.value), h = parseInt(imgHeightInput.value);
        if (isNaN(w) || w < 1) w = 100;
        if (isNaN(h) || h < 1) h = 100;
        overlayImage.style.width = w + 'px';
        overlayImage.style.height = h + 'px';
    });

    toggleMoveImageBtn.addEventListener('click', () => {
        if (!overlayImage) return;
        isImageMoveMode = !isImageMoveMode;
        if (isImageMoveMode) {
            toggleMoveImageBtn.textContent = "画像移動モード: ON";
            overlayImage.classList.add('moving');
            overlayImage.style.opacity = '1.0';
            overlayImage.style.pointerEvents = 'auto';
            overlayImage.style.cursor = 'move';
        } else {
            toggleMoveImageBtn.textContent = "画像移動モード: OFF";
            overlayImage.classList.remove('moving');
            overlayImage.style.opacity = '0.3';
            overlayImage.style.pointerEvents = 'none';
            overlayImage.style.cursor = 'default';
        }
    });

    deleteImageBtn.addEventListener('click', () => {
        if (overlayImage) {
            overlayImage.remove();
            overlayImage = null;
            isImageMoveMode = false; toggleMoveImageBtn.textContent = "画像移動モード: OFF";
        }
    });

    // 画像ドラッグ (mouse/touch)
    gridWrapper.addEventListener('mousedown', (e) => {
        if (!isImageMoveMode || !overlayImage) return;
        if (e.target !== overlayImage) return;
        draggingImage = true;
        dragStartX = e.clientX; dragStartY = e.clientY;
        imgStartLeft = parseInt(overlayImage.style.left) || 0;
        imgStartTop = parseInt(overlayImage.style.top) || 0;
        e.preventDefault();
    });
    window.addEventListener('mousemove', (e) => {
        if (!draggingImage || !overlayImage) return;
        const dx = e.clientX - dragStartX; const dy = e.clientY - dragStartY;
        let newLeft = imgStartLeft + dx; let newTop = imgStartTop + dy;
        const maxLeft = Math.max(0, gridWrapper.clientWidth - overlayImage.clientWidth);
        const maxTop = Math.max(0, gridWrapper.clientHeight - overlayImage.clientHeight);
        newLeft = Math.min(Math.max(0, newLeft), maxLeft); newTop = Math.min(Math.max(0, newTop), maxTop);
        overlayImage.style.left = newLeft + "px"; overlayImage.style.top = newTop + "px";
    });
    window.addEventListener('mouseup', (e) => { if (draggingImage) draggingImage = false; });

    gridWrapper.addEventListener('touchstart', (e) => {
        if (!isImageMoveMode || !overlayImage) return;
        if (e.target !== overlayImage) return;
        draggingImage = true;
        const t = e.touches[0];
        dragStartX = t.clientX; dragStartY = t.clientY;
        imgStartLeft = parseInt(overlayImage.style.left) || 0;
        imgStartTop = parseInt(overlayImage.style.top) || 0;
        e.preventDefault();
    }, {passive:false});
    window.addEventListener('touchmove', (e) => {
        if (!draggingImage || !overlayImage) return;
        const t = e.touches[0];
        const dx = t.clientX - dragStartX; const dy = t.clientY - dragStartY;
        let newLeft = imgStartLeft + dx; let newTop = imgStartTop + dy;
        const maxLeft = Math.max(0, gridWrapper.clientWidth - overlayImage.clientWidth);
        const maxTop = Math.max(0, gridWrapper.clientHeight - overlayImage.clientHeight);
        newLeft = Math.min(Math.max(0, newLeft), maxLeft); newTop = Math.min(Math.max(0, newTop), maxTop);
        overlayImage.style.left = newLeft + "px"; overlayImage.style.top = newTop + "px";
        e.preventDefault();
    }, {passive:false});
    window.addEventListener('touchend', () => { draggingImage = false; });

    function updateImagePositionAndLayer() {
        if (!overlayImage) return;
        if (isImageMoveMode) {
            overlayImage.style.zIndex = 25; overlayImage.style.opacity = '1.0'; overlayImage.style.pointerEvents = 'auto';
        } else {
            overlayImage.style.zIndex = 1; overlayImage.style.opacity = '0.3'; overlayImage.style.pointerEvents = 'none';
        }
    }

    // --- 画像→3D 変換（面選択） ---
    convertImageTo3dBtn.addEventListener('click', () => {
        if (!overlayImage) { alert('先に画像をインポートして'); return; }
        sideSelectionDiv.style.display = 'block';
    });
    cancelBtn.addEventListener('click', () => { sideSelectionDiv.style.display = 'none'; });
    sideSelectionDiv.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON' && e.target.dataset.side) {
            sideSelectionDiv.style.display = 'none';
            convertImageTo3d(e.target.dataset.side);
        }
    });

    function convertImageTo3d(side) {
        if (!overlayImage) return;
        saveStateForUndo();
        const img = new Image(); img.crossOrigin = 'Anonymous'; img.src = overlayImage.src;
        img.onload = () => {
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            let finalW, finalH;
            if (side === 'front' || side === 'back') { finalW = width; finalH = height; }
            else if (side === 'left' || side === 'right') { finalW = depth; finalH = height; }
            else { finalW = width; finalH = depth; }
            // maintain aspect
            const imgRatio = img.width / img.height; const gridRatio = finalW / finalH;
            if (imgRatio > gridRatio) finalH = Math.round(finalW / imgRatio);
            else finalW = Math.round(finalH * imgRatio);
            canvas.width = Math.max(1, Math.round(finalW)); canvas.height = Math.max(1, Math.round(finalH));
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
            const data = imageData.data;
            for (let y=0;y<canvas.height;y++){
                for (let x=0;x<canvas.width;x++){
                    const i = (y*canvas.width + x)*4;
                    const r = data[i], g=data[i+1], b=data[i+2], a=data[i+3];
                    if (a === 0) continue;
                    const hex = '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
                    let vx, vy, vz;
                    if (side==='front') { vx = x; vy = height-1 - y; vz = depth-1; }
                    else if (side==='back') { vx = x; vy = height-1 - y; vz = 0; }
                    else if (side==='left') { vx = 0; vy = height-1 - y; vz = x; }
                    else if (side==='right') { vx = width-1; vy = height-1 - y; vz = x; }
                    else if (side==='top') { vx = x; vy = height-1; vz = y; }
                    else { vx = x; vy = 0; vz = y; }
                    if (vx>=0&&vx<width&&vy>=0&&vy<height&&vz>=0&&vz<depth) voxelData[vy][vz][vx] = hex;
                }
            }
            renderGrid(); if (is3DInitialized) update3DView();
        };
    }

    // --- 3D表示 / OBJエクスポート / JSON保存 ---
    function init3DView() {
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x222222);
        camera = new THREE.PerspectiveCamera(60, document.getElementById('renderer-container').clientWidth / document.getElementById('renderer-container').clientHeight, 0.1, 1000);
        camera.position.set(width*1.2, height*1.2, depth*1.2);
        renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('threejs-canvas'), antialias:true });
        renderer.setSize(document.getElementById('renderer-container').clientWidth, document.getElementById('renderer-container').clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(50,50,50); scene.add(dirLight);
        is3DInitialized = true;
        update3DView();
        animate();
    }

    function update3DView() {
        if (!is3DInitialized) return;
        voxelMeshes.forEach(m=>scene.remove(m)); voxelMeshes=[];
        const geometry = new THREE.BoxGeometry(1,1,1);
        const centerOffsetX = (width-1)/2, centerOffsetY=(height-1)/2, centerOffsetZ=(depth-1)/2;
        for (let y=0;y<height;y++){
            for (let z=0;z<depth;z++){
                for (let x=0;x<width;x++){
                    const color = voxelData[y][z][x];
                    if (color) {
                        const mat = new THREE.MeshPhongMaterial({ color });
                        const cube = new THREE.Mesh(geometry, mat);
                        cube.position.set(x - centerOffsetX, y - centerOffsetY, z - centerOffsetZ);
                        scene.add(cube); voxelMeshes.push(cube);
                    }
                }
            }
        }
    }
    function animate() { requestAnimationFrame(animate); if (controls) controls.update(); if (renderer) renderer.render(scene, camera); }

    document.getElementById('show3dBtn').addEventListener('click', () => {
        document.getElementById('renderer-container').style.display='block';
        document.getElementById('grid-container').style.display='none';
        if (!is3DInitialized) init3DView();
        update3DView();
    });
    document.getElementById('show2dBtn').addEventListener('click', () => {
        document.getElementById('renderer-container').style.display='none';
        document.getElementById('grid-container').style.display='block';
    });

    function saveJSON() {
        const data = { width, height, depth, voxelData };
        const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = "voxel_data.json"; a.click();
        URL.revokeObjectURL(url);
    }

    function saveOBJ() {
        const zip = new JSZip();
        let obj = "mtllib model.mtl\n";
        let mtl = "";
        const vertexMap = new Map(); const vertices = []; let currentIndex = 1;
        const facesByMaterial = {}; const materialSet = new Set();
        const scale = 1.0;
        function getVertexIndex(x,y,z) {
            const key = `${x},${y},${z}`;
            if (vertexMap.has(key)) return vertexMap.get(key);
            vertexMap.set(key, currentIndex);
            vertices.push(`v ${x*scale} ${y*scale} ${z*scale}`);
            return currentIndex++;
        }
        function rgbFromHex(hex) {
            const value = parseInt(hex.slice(1),16);
            const r = ((value>>16)&0xff)/255;
            const g = ((value>>8)&0xff)/255;
            const b = (value&0xff)/255;
            return { r,g,b };
        }
        function addFace(v1,v2,v3,v4,mat) {
            if (!facesByMaterial[mat]) facesByMaterial[mat]=[];
            facesByMaterial[mat].push(`f ${v1} ${v2} ${v3} ${v4}`);
        }
        for (let y=0;y<height;y++){
            for (let z=0;z<depth;z++){
                for (let x=0;x<width;x++){
                    const color = voxelData[y][z][x]; if (!color) continue;
                    const matName = "mat_"+color.slice(1);
                    if (!materialSet.has(matName)) {
                        materialSet.add(matName);
                        const {r,g,b} = rgbFromHex(color);
                        mtl += `newmtl ${matName}\nKd ${r.toFixed(4)} ${g.toFixed(4)} ${b.toFixed(4)}\n\n`;
                    }
                    const px=x, py=y, pz=z;
                    const v000 = getVertexIndex(px,py,pz);
                    const v100 = getVertexIndex(px+1,py,pz);
                    const v010 = getVertexIndex(px,py+1,pz);
                    const v110 = getVertexIndex(px+1,py+1,pz);
                    const v001 = getVertexIndex(px,py,pz+1);
                    const v101 = getVertexIndex(px+1,py,pz+1);
                    const v011 = getVertexIndex(px,py+1,pz+1);
                    const v111 = getVertexIndex(px+1,py+1,pz+1);
                    if (y === height-1 || !voxelData[y+1]?.[z]?.[x]) addFace(v011, v111, v110, v010, matName);
                    if (y === 0 || !voxelData[y-1]?.[z]?.[x]) addFace(v000, v100, v101, v001, matName);
                    if (x === width-1 || !voxelData[y]?.[z]?.[x+1]) addFace(v100, v110, v111, v101, matName);
                    if (x === 0 || !voxelData[y]?.[z]?.[x-1]) addFace(v001, v011, v010, v000, matName);
                    if (z === depth-1 || !voxelData[y]?.[z+1]?.[x]) addFace(v001, v101, v111, v011, matName);
                    if (z === 0 || !voxelData[y]?.[z-1]?.[x]) addFace(v100, v000, v010, v110, matName);
                }
            }
        }
        obj += vertices.join('\n') + '\n';
        for (const matName in facesByMaterial) {
            obj += `usemtl ${matName}\n`;
            obj += facesByMaterial[matName].join('\n') + '\n';
        }
        const zipContent = new Blob([obj + '\n---MTL---\n' + mtl], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(zipContent);
        const a = document.createElement('a'); a.href = url; a.download = "voxel_model.obj"; a.click();
        URL.revokeObjectURL(url);
    }

    document.getElementById('saveJsonBtn').addEventListener('click', saveJSON);
    document.getElementById('saveObjBtn').addEventListener('click', saveOBJ);
    document.getElementById('save3dImageBtn').addEventListener('click', () => {
        if (!is3DInitialized) return;
        renderer.render(scene, camera);
        const dataURL = renderer.domElement.toDataURL("image/png");
        const a = document.createElement('a'); a.href = dataURL; a.download = `voxel_3dview.png`; a.click();
    });
    document.getElementById('undoBtn').addEventListener('click', undo);

    // --- リサイズ / レイヤー移動 / 初期化 ---
    document.getElementById('resizeBtn').addEventListener('click', () => {
        const newW = parseInt(document.getElementById("inputWidth").value);
        const newH = parseInt(document.getElementById("inputHeight").value);
        const newD = parseInt(document.getElementById("inputDepth").value);
        if (newW > 0 && newH > 0 && newD > 0) {
            saveStateForUndo();
            resizeVoxelData(newW,newH,newD);
            width=newW; height=newH; depth=newD;
            if (currentLayer >= height) currentLayer = height-1;
            document.getElementById("inputHeight").value = height;
            updateLayerLabel(); initGrid(); renderGrid(); if (is3DInitialized) update3DView();
        }
    });
    function resizeVoxelData(newW,newH,newD) {
        const newData = Array.from({ length: newH }, () =>
            Array.from({ length: newD }, () =>
                Array.from({ length: newW }, () => null)
            )
        );
        for (let y = 0; y < Math.min(height, newH); y++) {
            for (let z = 0; z < Math.min(depth, newD); z++) {
                for (let x = 0; x < Math.min(width, newW); x++) {
                    newData[y][z][x] = voxelData[y]?.[z]?.[x] || null;
                }
            }
        }
        voxelData = newData;
    }

    document.getElementById('layerPrevBtn').addEventListener('click', () => { if (currentLayer>0) currentLayer--; updateLayerLabel(); renderGrid(); });
    document.getElementById('layerNextBtn').addEventListener('click', () => { if (currentLayer<height-1) currentLayer++; updateLayerLabel(); renderGrid(); });

    // --- リセット ---
    document.getElementById('resetBtn').addEventListener('click', () => {
        if (!confirm("本当にリセットする？未保存のデータは消えるよ？")) return;
        saveStateForUndo();
        initData(); currentLayer=0; updateLayerLabel(); renderGrid();
        if (is3DInitialized) update3DView();
        if (overlayImage) { overlayImage.remove(); overlayImage=null; isImageMoveMode=false; toggleMoveImageBtn.textContent="画像移動モード: OFF"; }
    });

    // --- ブラシ/カラー/モードUIイベント ---
    document.getElementById("brushSize").addEventListener('input', e=> { brushSize = parseInt(e.target.value); document.getElementById("brushSizeValue").textContent = brushSize; });
    document.getElementById("colorPicker").addEventListener('input', e => { drawColor = e.target.value; isErasing=false; setMode('draw'); });
    document.getElementById("drawBtn").addEventListener('click', () => { isErasing=false; setMode('draw'); });
    document.getElementById("eraseBtn").addEventListener('click', () => { isErasing=true; setMode('erase'); });

    // --- 画像→3D面に配置するためのスライド移動(既にisImageMoveModeで対応) ---
    // 面に配置時もoverlayImageの現在の位置を考慮して配置（必要であれば追加ロジック作れる）

    // --- 図形プリセット実装 ---
    document.getElementById('circleBtn').addEventListener('click', () => { shapeMode='circle'; shapeSize=5; shapeAngle=0; showShapeControls(); renderGrid(); });
    document.getElementById('rectBtn').addEventListener('click', () => { shapeMode='rect'; shapeSize=5; shapeAngle=0; showShapeControls(); renderGrid(); });
    document.getElementById('triBtn').addEventListener('click', () => { shapeMode='tri'; shapeSize=5; shapeAngle=0; showShapeControls(); renderGrid(); });

    function showShapeControls() { shapeControlsDiv.style.display='flex'; shapeSizeLabel.textContent = shapeSize; }
    function hideShapeControls() { shapeControlsDiv.style.display='none'; shapeMode=null; renderGrid(); }

    document.getElementById('shapeIncBtn').addEventListener('click', () => { shapeSize++; shapeSizeLabel.textContent = shapeSize; renderGrid(); });
    document.getElementById('shapeDecBtn').addEventListener('click', () => { if (shapeSize>1) shapeSize--; shapeSizeLabel.textContent = shapeSize; renderGrid(); });
    document.getElementById('shapeRotateBtn').addEventListener('click', () => { shapeAngle = (shapeAngle + 90) % 360; renderGrid(); });
    document.getElementById('shapeCancelBtn').addEventListener('click', () => { hideShapeControls(); });

    // shapeMove: マウス移動でshapeX/shapeZ更新
    document.getElementById('shapeMoveBtn').addEventListener('click', () => {
        const moveHandler = (e) => {
            const el = document.elementFromPoint(e.clientX, e.clientY);
            if (el && el.classList && el.classList.contains('cell')) {
                shapeX = parseInt(el.dataset.x); shapeZ = parseInt(el.dataset.z);
                renderGrid();
            }
        };
        grid.addEventListener('mousemove', moveHandler, { once:false });
        // ワンクリックで解除はしない。キャンセルか配置で解除
        alert('セル上を動かして配置位置を決めて。配置したければ「配置」押して。');
    });

    document.getElementById('shapePlaceBtn').addEventListener('click', () => {
        placeShapeToLayer();
        hideShapeControls();
    });

    function getShapeCoordsPreview() {
        const pts = [];
        if (!shapeMode) return pts;
        if (shapeMode === 'circle') {
            const r = shapeSize;
            for (let dz = -r; dz <= r; dz++) for (let dx = -r; dx <= r; dx++) if (dx*dx + dz*dz <= r*r + 0.5) pts.push({ x: shapeX + dx, z: shapeZ + dz });
        } else if (shapeMode === 'rect') {
            for (let dz = 0; dz < shapeSize; dz++) for (let dx = 0; dx < shapeSize; dx++) pts.push({ x: shapeX + dx, z: shapeZ + dz });
        } else if (shapeMode === 'tri') {
            for (let dz = 0; dz < shapeSize; dz++) for (let dx = 0; dx <= dz; dx++) {
                let px = shapeX + dx, pz = shapeZ + dz;
                if (shapeAngle === 90) [px,pz] = [shapeX + dz, shapeZ + dx];
                if (shapeAngle === 180) [px,pz] = [shapeX - dx, shapeZ + dz];
                if (shapeAngle === 270) [px,pz] = [shapeX + dz, shapeZ - dx];
                pts.push({ x: px, z: pz });
            }
        }
        return pts;
    }

    function placeShapeToLayer() {
        const pts = getShapeCoordsPreview();
        saveStateForUndo();
        for (let p of pts) {
            if (p.x>=0 && p.x<width && p.z>=0 && p.z<depth) voxelData[currentLayer][p.z][p.x] = drawColor;
        }
        renderGrid();
        if (is3DInitialized) update3DView();
    }

    // --- grid touch/mouse to update shapeX/shapeZ preview when shapeMode active ---
    grid.addEventListener('mousemove', (e) => {
        if (!shapeMode) return;
        const el = document.elementFromPoint(e.clientX, e.clientY);
        if (el && el.classList && el.classList.contains('cell')) {
            shapeX = parseInt(el.dataset.x); shapeZ = parseInt(el.dataset.z);
            renderGrid();
        }
    });
    grid.addEventListener('touchmove', (e) => {
        if (!shapeMode) return;
        const t = e.touches[0];
        const el = document.elementFromPoint(t.clientX, t.clientY);
        if (el && el.classList && el.classList.contains('cell')) {
            shapeX = parseInt(el.dataset.x); shapeZ = parseInt(el.dataset.z);
            renderGrid();
        }
    }, {passive:false});

    // --- ユーティリティ: マウスアップで選択確定（タップでも動く） ---
    document.getElementById('grid').addEventListener('mouseup', (e) => {
        // 選択モードでマウスアップ->領域計算 (単にボタンで確定させたいからここでは何もしない)
    });

    // --- 初期化実行 ---
    initData(); updateLayerLabel(); initGrid(); renderGrid(); setMode('draw');

    // --- スクロールボタン ---
    document.getElementById('scrollUp').addEventListener('click', ()=>grid.parentElement.scrollBy(0,-50));
    document.getElementById('scrollDown').addEventListener('click', ()=>grid.parentElement.scrollBy(0,50));
    document.getElementById('scrollLeft').addEventListener('click', ()=>grid.parentElement.scrollBy(-50,0));
    document.getElementById('scrollRight').addEventListener('click', ()=>grid.parentElement.scrollBy(50,0));

    // --- JSONインポート ---
    const importJsonInput = document.getElementById('importJsonInput');
    importJsonInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
            try {
                const data = JSON.parse(reader.result);
                if (typeof data.width==='number' && typeof data.height==='number' && typeof data.depth==='number' && Array.isArray(data.voxelData)) {
                    width = data.width; height = data.height; depth = data.depth; voxelData = data.voxelData;
                    document.getElementById("inputWidth").value = width;
                    document.getElementById("inputHeight").value = height;
                    document.getElementById("inputDepth").value = depth;
                    currentLayer = 0; updateLayerLabel(); initGrid(); renderGrid();
                    if (is3DInitialized) update3DView();
                } else alert('不正なJSON');
            } catch(err){ alert('JSON読み込み失敗'); console.error(err); }
            importJsonInput.value = '';
        };
        reader.readAsText(file);
    });

    // --- セルクリックで色塗り（mouse/touch共通） ---
    grid.addEventListener('click', (e) => {
        const cell = e.target.closest('.cell'); if (!cell) return;
        const x = parseInt(cell.dataset.x), z = parseInt(cell.dataset.z);
        if (currentMode === 'draw' || currentMode === 'erase') {
            paintCells(x,z);
        } else if (currentMode === 'move') {
            // selection move toggle handled elsewhere
        }
    });

    // --- 追加: ヘルプ的にキー操作（任意） ---
    window.addEventListener('keydown', (e)=> {
        if (e.key === 'Delete') {
            // delete selection
            if (selectedCells.length) {
                saveStateForUndo();
                for (let c of selectedCells) voxelData[currentLayer][c.z][c.x] = null;
                clearSelection(); renderGrid();
            }
        }
    });

    // --- 最後: shape初期ラベル更新 & レスポンシブ対応 ---
    window.addEventListener('resize', ()=> {
        if (is3DInitialized) {
            renderer.setSize(document.getElementById('renderer-container').clientWidth, document.getElementById('renderer-container').clientHeight);
            camera.aspect = document.getElementById('renderer-container').clientWidth / document.getElementById('renderer-container').clientHeight;
            camera.updateProjectionMatrix();
        }
    });

    </script>
</body>
</html>
