<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>Voxelエディタ with 画像機能フル版</title>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
            background-color: #222;
            color: #fff;
            overscroll-behavior: none;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            background: #333;
        }
        #top-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        #tab-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        .tab-content {
            display: none;
            flex-wrap: wrap;
            gap: 10px;
            padding: 5px 0;
            align-items: center;
        }
        .tab-content.active {
            display: flex;
        }
        #controls button,
        #controls input[type="color"],
        #controls input[type="number"],
        #controls input[type="range"],
        #controls input[type="file"] {
            padding: 5px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            background-color: #444;
            color: #fff;
            cursor: pointer;
        }
        #controls button:hover,
        .custom-file-label:hover {
            background-color: #666;
        }
        .tab-button.active {
            background-color: #007bff;
        }
        #grid-container {
            width: 80vw;
            height: 70vh;
            overflow: auto;
            border: 2px solid #444;
            margin: 10px;
            position: relative;
        }
        #grid-wrapper {
            position: relative;
        }
        #grid {
            position: relative;
            z-index: 20;
            display: grid;
            touch-action: none;
        }
        .cell {
            width: 20px;
            height: 20px;
            border: 1px solid #555;
            box-sizing: border-box;
            position: relative;
        }
        .cell-highlight {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.2);
            pointer-events: none;
        }
        #selection-box {
            position: absolute;
            background-color: rgba(0, 100, 255, 0.4);
            border: 1px dashed rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 50;
        }
        /* 【修正】選択中のセルはJSで透過色を設定するため、opacityを削除 */
        .selecting-cell, .selected-cell {
            border: 1px solid rgba(255, 255, 255, 0.8) !important;
        }
        .moving-box {
            background-color: rgba(255, 255, 255, 0.1) !important;
            border: 2px dashed rgba(255, 255, 255, 0.8) !important;
        }
        #renderer-container {
            display: none;
            width: 80vw;
            height: 70vh;
            margin: 10px;
            border: 2px solid #444;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #scrollButtons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }
        #scrollButtons button {
            background-color: #555;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            font-size: 16px;
        }
        #scrollButtons button:hover {
            background-color: #888;
        }
        .overlay-image {
            position: absolute;
            opacity: 0.3;
            pointer-events: none;
            z-index: 1;
            user-select: none;
        }
        .overlay-image.moving {
            opacity: 0.5;
            pointer-events: none;
            z-index: 10;
            cursor: move;
        }
        .custom-file-label {
            padding: 6px 12px;
            background-color: #444;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            display: inline-block;
            font-size: 14px;
            border: none;
            transition: background-color 0.3s ease;
        }
        .custom-file-label:hover {
            background-color: #666;
        }
        #sideSelection {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background: #444;
            border: 1px solid #666;
            z-index: 1001;
            border-radius: 8px;
            text-align: center;
        }
        #sideSelection p {
            margin-top: 0;
        }
        #sideSelection button {
            margin: 5px;
            padding: 8px 15px;
            background-color: #555;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        /* 【新規】図形コントロール */
        #shapeControls {
            display: none;
            position: fixed;
            top: 150px;
            left: 20px;
            background: #333;
            padding: 10px;
            border-radius: 4px;
            gap: 5px;
            flex-direction: column;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div id="top-controls">
            <div id="tab-buttons">
                <button class="tab-button active" data-tab="drawTab">描画</button>
                <button class="tab-button" data-tab="selectMoveTab">選択移動</button>
                <button class="tab-button" data-tab="insertTab">挿入</button>
                <button class="tab-button" data-tab="convertTab">変換</button>
                <button class="tab-button" data-tab="exportTab">エクスポート</button>
            </div>
            <button id="show2dBtn">2D表示</button>
            <button id="show3dBtn">3D表示</button>
            <input type="number" id="inputWidth" value="16" min="1" max="64" />×
            <input type="number" id="inputHeight" value="16" min="1" max="64" />×
            <input type="number" id="inputDepth" value="16" min="1" max="64" />
            <button id="resizeBtn">サイズ変更</button>
            <button id="layerPrevBtn">↑</button>
            <button id="layerNextBtn">↓</button>
            <span id="layerLabel"></span>
        </div>

        <div id="drawTab" class="tab-content active">
            <input type="color" id="colorPicker" value="#ff0000" />
            <button id="drawBtn">描画</button>
            <button id="eraseBtn">消去</button>
            <input type="range" id="brushSize" min="1" max="5" value="1" />
            <span id="brushSizeValue">1</span>
            <button id="circleBtn">円</button>
            <button id="squareBtn">四角</button>
            <button id="triangleBtn">三角</button>
        </div>

        <div id="selectMoveTab" class="tab-content">
            <button id="selectBtn">選択</button>
            <button id="completeSelectionBtn" style="display:none;">選択完了</button>
            <button id="cancelSelectionBtn" style="display:none;">キャンセル</button>
            <button id="copyBtn">コピー</button>
            <button id="cutBtn">カット</button>
            <button id="pasteBtn">ペースト</button>
            <button id="copyLayerAddBtn">レイヤーコピーして追加</button>
        </div>
        <div id="insertTab" class="tab-content">
            <input type="file" id="importJsonInput" accept=".json" style="display:none;" />
            <label for="importJsonInput" class="custom-file-label">JSONインポート</label>
            <input type="file" id="imageInput" accept="image/*" style="display:none;" />
            <label for="imageInput" class="custom-file-label">画像インポート</label>
        </div>

        <div id="convertTab" class="tab-content">
            <button id="convertImageTo3dBtn">画像3D変換</button>
            <input type="number" id="imgWidth" value="100" style="width: 60px;" />×
            <input type="number" id="imgHeight" value="100" style="width: 60px;" />
            <button id="applyImageSize">画像サイズ変更</button>
            <button id="toggleMoveImage">画像移動モード: OFF</button>
            <button id="deleteImageBtn">画像削除</button>
        </div>

        <div id="exportTab" class="tab-content">
            <button id="saveObjBtn">OBJエクスポート</button>
            <button id="saveJsonBtn">JSONエクスポート</button>
            <button id="save3dImageBtn">スクショ</button>
        </div>
    </div>
    
    <div id="shapeControls">
        <button id="scaleUpBtn" title="拡大">+</button>
        <button id="scaleDownBtn" title="縮小">-</button>
        <button id="rotateBtn" title="回転">回転</button>
    </div>

    <div id="grid-container">
        <div id="grid-wrapper">
            <div id="grid"></div>
            <div id="selection-box" style="display:none;"></div>
        </div>
    </div>

    <div id="renderer-container">
        <canvas id="threejs-canvas"></canvas>
    </div>

    <div id="sideSelection">
        <p>どの面に画像を配置しますか？</p>
        <button data-side="front">前面</button>
        <button data-side="back">背面</button>
        <button data-side="left">左面</button>
        <button data-side="right">右面</button>
        <button data-side="top">上面</button>
        <button data-side="bottom">下面</button>
        <button id="cancelBtn">キャンセル</button>
    </div>

    <div id="scrollButtons">
        <button id="scrollUp">↑</button>
        <button id="scrollDown">↓</button>
        <button id="scrollLeft">←</button>
        <button id="scrollRight">→</button>
        <button id="undoBtn">元に戻す</button>
        <button id="resetBtn">リセット</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let width = 16, height = 16, depth = 16;
        let currentLayer = 0;
        let drawColor = "#ff0000";
        let isErasing = false;
        let brushSize = 1;
        let voxelData = [];
        let scene, camera, renderer, controls;
        let is3DInitialized = false;
        let voxelMeshes = [];
        let undoStack = [];
        let cells = [];
        let overlayImage = null;
        let isImageMoveMode = false;
        let dragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let imgStartLeft = 0;
        let imgStartTop = 0;
        // クリップボード関連の変数
        let clipboardVoxelData = []; 
        // 【新規追加】図形プリセット関連
        let currentShape = null; // 'circle', 'square', 'triangle'
        let shapeSize = 5; // 図形の初期サイズ
        let shapeRotation = 0; // 図形の回転角度 (0, 90, 180, 270)
        let shapeVoxelData = { data: [], clipWidth: 0, clipDepth: 0 }; // 図形を構成するボクセルデータ (相対座標)
        let isShapeMoving = false;
        let shapeStartGridX, shapeStartGridZ; // 図形の貼り付け開始位置

        const grid = document.getElementById("grid");
        const layerLabel = document.getElementById("layerLabel");
        const canvas = document.getElementById("threejs-canvas");
        const rendererContainer = document.getElementById("renderer-container");
        const gridContainer = document.getElementById("grid-container");
        const gridWrapper = document.getElementById("grid-wrapper");
        const imageInput = document.getElementById('imageInput');
        const imgWidthInput = document.getElementById('imgWidth');
        const imgHeightInput = document.getElementById('imgHeight');
        const applyImageSizeBtn = document.getElementById('applyImageSize');
        const toggleMoveImageBtn = document.getElementById('toggleMoveImage');
        const deleteImageBtn = document.getElementById('deleteImageBtn');
        const convertImageTo3dBtn = document.getElementById('convertImageTo3dBtn');
        const sideSelectionDiv = document.getElementById('sideSelection');
        const cancelBtn = document.getElementById('cancelBtn');

        let currentMode = 'draw';
        let isDrawing = false;
        let isSelecting = false;
        let isMoving = false;
        let startCellX, startCellZ;
        let selectedCells = [];
        let selectedVoxelData = [];
        let movingStartMouseX, movingStartMouseY;
        let movingStartGridX, movingStartGridZ;

        const selectBtn = document.getElementById('selectBtn');
        const drawBtn = document.getElementById('drawBtn');
        const eraseBtn = document.getElementById('eraseBtn');
        const completeSelectionBtn = document.getElementById('completeSelectionBtn');
        const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
        const selectionBox = document.getElementById('selection-box');
        // クリップボード/レイヤー操作ボタン
        const copyBtn = document.getElementById('copyBtn');
        const cutBtn = document.getElementById('cutBtn');
        const pasteBtn = document.getElementById('pasteBtn');
        const copyLayerAddBtn = document.getElementById('copyLayerAddBtn');
        
        // レイヤー操作ボタン
        const layerPrevBtn = document.getElementById('layerPrevBtn');
        const layerNextBtn = document.getElementById('layerNextBtn');
        const undoBtn = document.getElementById('undoBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        // 【新規】図形プリセットDOM
        const circleBtn = document.getElementById('circleBtn');
        const squareBtn = document.getElementById('squareBtn');
        const triangleBtn = document.getElementById('triangleBtn');
        const shapeControls = document.getElementById('shapeControls');
        const scaleUpBtn = document.getElementById('scaleUpBtn');
        const scaleDownBtn = document.getElementById('scaleDownBtn');
        const rotateBtn = document.getElementById('rotateBtn');
        
        // --- ヘルパー関数: HEX to RGBA (機能②用) ---
        function hexToRgba(hex, alpha) {
            if (!hex || hex.length !== 7) return 'transparent';
            const r = parseInt(hex.substring(1, 3), 16);
            const g = parseInt(hex.substring(3, 5), 16);
            const b = parseInt(hex.substring(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // --- タブ切り替えのロジック ---
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));

                button.classList.add('active');
                const targetTab = document.getElementById(button.dataset.tab);
                if (targetTab) {
                    targetTab.classList.add('active');
                }
                
                if (button.dataset.tab === 'drawTab') {
                    setMode('draw');
                } else if (button.dataset.tab === 'selectMoveTab') {
                    setMode('select');
                } else {
                    setMode('none');
                }
            });
        });

        function setMode(mode) {
            currentMode = mode;
            drawBtn.style.display = 'inline-block';
            eraseBtn.style.display = 'inline-block';
            selectBtn.style.display = 'inline-block';
            completeSelectionBtn.style.display = 'none';
            cancelSelectionBtn.style.display = 'none';

            document.querySelectorAll('#drawTab button').forEach(btn => btn.style.backgroundColor = '');
            document.querySelectorAll('#selectMoveTab button').forEach(btn => btn.style.backgroundColor = '');
            
            // 【新規】図形コントロールの表示/非表示
            shapeControls.style.display = 'none';
            
            if (mode === 'draw') {
                drawBtn.style.backgroundColor = '#666';
                currentShape = null;
            } else if (mode === 'erase') {
                eraseBtn.style.backgroundColor = '#666';
                currentShape = null;
            } else if (mode === 'select' || mode === 'move') {
                selectBtn.style.backgroundColor = '#666';
                completeSelectionBtn.style.display = 'inline-block';
                cancelSelectionBtn.style.display = 'inline-block';
                currentShape = null;
            } else if (mode === 'shapeMove') { // 【新規】図形配置モード
                completeSelectionBtn.style.display = 'inline-block';
                cancelSelectionBtn.style.display = 'inline-block';
                shapeControls.style.display = 'flex';
                // 図形ボタンのハイライトは維持
            } else {
                currentShape = null;
            }
            
            if (mode !== 'select' && mode !== 'move' && mode !== 'shapeMove') {
                clearSelection();
            }
            
            // 図形モードから抜ける際にクリア
            if (mode !== 'shapeMove') {
                shapeVoxelData = { data: [], clipWidth: 0, clipDepth: 0 };
                isShapeMoving = false;
                
                // 描画モードに戻るときは、図形ボタンのハイライトをクリア
                if (mode === 'draw' || mode === 'erase') {
                    circleBtn.style.backgroundColor = '';
                    squareBtn.style.backgroundColor = '';
                    triangleBtn.style.backgroundColor = '';
                }
            }
        }
        
        function clearSelection() {
            selectedCells = [];
            selectedVoxelData = [];
            isSelecting = false;
            isMoving = false;
            // 【新規】図形モードのフラグもクリア
            isShapeMoving = false;
            currentShape = null;
            shapeVoxelData = { data: [], clipWidth: 0, clipDepth: 0 };

            selectionBox.style.display = 'none';
            selectionBox.classList.remove('moving-box');
            cells.flat().forEach(cell => {
                cell.classList.remove('selecting-cell', 'selected-cell'); // selected-cellもクリア
                // 【修正】透過表示のために追加したスタイルをリセット
                cell.style.backgroundColor = ''; 
            });
            updateGridColors();
        }
        
        function getCellFromPoint(clientX, clientY) {
            const rect = grid.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            const cellX = Math.floor(x / 20);
            const cellZ = Math.floor(y / 20);
            if (cellX >= 0 && cellX < width && cellZ >= 0 && cellZ < depth) {
                return cells[cellZ][cellX];
            }
            return null;
        }

        selectBtn.addEventListener('click', () => {
            setMode('select');
            clearSelection();
        });
        drawBtn.addEventListener('click', () => {
            isErasing = false;
            setMode('draw');
        });
        eraseBtn.addEventListener('click', () => {
            isErasing = true;
            setMode('erase');
        });
        cancelSelectionBtn.addEventListener('click', () => {
            clearSelection();
            setMode('select');
        });
        
        // 【completeSelectionBtnの修正 (機能②の透過維持と機能⑤の確定)】
        completeSelectionBtn.addEventListener('click', () => {
            if (isSelecting) {
                isSelecting = false;
                const rect = selectionBox.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                const startX = Math.round((rect.left - gridRect.left) / 20);
                const startZ = Math.round((rect.top - gridRect.top) / 20);
                const endX = startX + Math.round(rect.width / 20) - 1;
                const endZ = startZ + Math.round(rect.height / 20) - 1;
                selectedCells = [];
                selectedVoxelData = [];
                for (let z = startZ; z <= endZ; z++) {
                    for (let x = startX; x <= endX; x++) {
                        const color = voxelData[currentLayer][z][x];
                        if (color) {
                            selectedCells.push({ x, z, color });
                            // 相対座標で保存
                            selectedVoxelData.push({ x: x - startX, z: z - startZ, color });
                        }
                    }
                }
                
                // 元の場所からボクセルデータを削除（カット処理に相当）
                selectedCells.forEach(cell => {
                    voxelData[currentLayer][cell.z][cell.x] = null;
                });
                updateGridColors();
                selectionBox.style.display = 'block';
                selectionBox.classList.add('moving-box');

                // 移動モードのための初期座標を設定
                movingStartGridX = startX;
                movingStartGridZ = startZ;

                setMode('move');
                return;
            }
            // 【修正】図形配置モードの確定
            if (currentMode === 'shapeMove' && shapeVoxelData.data.length > 0) {
                // voxelDataには既に図形が書き込まれているので、クリアして描画モードに戻るだけ
                clearSelection(); 
                setMode('draw'); 
                if (is3DInitialized) update3DView();
                alert("図形の配置を確定しました。");
                return;
            }
            
            if (currentMode === 'move' && selectedVoxelData.length > 0) {
                // 確定処理
                clearSelection();
                setMode('select');
                if (is3DInitialized) update3DView();
            } else {
                clearSelection();
                setMode('select');
            }
        });
        // --- コピー/カット/ペースト機能のロジック (機能③) ---

        function isSelectionMovable() {
            return currentMode === 'move' && selectedVoxelData.length > 0;
        }

        // コピー機能
        copyBtn.addEventListener('click', () => {
            if (!isSelectionMovable()) {
                alert("コピーするボクセルを選択し、「選択完了」ボタンを押して移動モードにしてください。");
                return;
            }
            
            // selectedVoxelDataは既に相対座標になっているのでそのままコピー
            clipboardVoxelData = selectedVoxelData.map(v => ({ ...v }));
            alert(`ボクセル ${clipboardVoxelData.length} 個をコピーしました。`);
        });
        // カット機能
        cutBtn.addEventListener('click', () => {
            if (!isSelectionMovable()) {
                alert("カットするボクセルを選択し、「選択完了」ボタンを押して移動モードにしてください。");
                return;
            }

            saveStateForUndo(); 

            // 1. コピー処理 (selectedVoxelDataをクリップボードに保存)
            clipboardVoxelData = selectedVoxelData.map(v => ({ ...v }));

            // 2. 選択状態のクリアとモード変更
            clearSelection(); 
            setMode('select'); 
            
            updateGridColors(); 
            if (is3DInitialized) update3DView();
            alert(`ボクセル ${clipboardVoxelData.length} 個をカットし、クリップボードに保存しました。`);
        });
        // ペースト機能
        pasteBtn.addEventListener('click', () => {
            if (clipboardVoxelData.length === 0) {
                alert("クリップボードにデータがありません。");
                return;
            }

            clearSelection();
          
            selectedVoxelData = clipboardVoxelData.map(v => ({ ...v }));
            
            // 貼り付け開始位置を計算 (グリッド中央付近)
            const startX = Math.floor((width - 1) / 2);
            const startZ = Math.floor((depth - 1) / 2);
            
            // 選択範囲のバウンディングボックスのサイズを計算
            let minX = Infinity, minZ = Infinity, maxX = -Infinity, maxZ = -Infinity;
            selectedVoxelData.forEach(v => {
                minX = Math.min(minX, v.x);
                minZ = Math.min(minZ, v.z);
                maxX = Math.max(maxX, v.x);
                maxZ = Math.max(maxZ, v.z);
            });
            
            const clipWidth = maxX - minX + 1;
            const clipDepth = maxZ - minZ + 1;

            // 中央に配置するための調整
            const finalStartX = startX - Math.floor(clipWidth / 2);
            const finalStartZ = startZ - Math.floor(clipDepth / 2);

            // 選択ボックスを表示し、移動モードへ移行
            selectionBox.style.display = 'block';
            selectionBox.classList.add('moving-box');
            selectionBox.style.left = `${finalStartX * 20}px`;
            selectionBox.style.top = `${finalStartZ * 20}px`;
            selectionBox.style.width = `${clipWidth * 20}px`;
            selectionBox.style.height = `${clipDepth * 20}px`;
            
            saveStateForUndo(); 
            
            // 初期の貼り付け（移動モードに入るため、一度書き込む）
            selectedCells = [];
            selectedVoxelData.forEach(voxel => {
                const newX = finalStartX + voxel.x;
                const newZ = finalStartZ + voxel.z;
                if (newX >= 0 && newX < width && newZ >= 0 && newZ < depth) {
                    voxelData[currentLayer][newZ][newX] = voxel.color;
                    selectedCells.push({ x: newX, z: newZ }); // 選択セルを更新
                }
            });
            updateGridColors(); // グリッドを更新
            
            // 移動モードのための初期座標を設定
            movingStartGridX = finalStartX;
            movingStartGridZ = finalStartZ;

            setMode('move'); // 移動モードへ
            alert("ペーストしました。選択範囲を移動・確定してください。");
        });
        
        // --- 図形描画アルゴリズム (機能⑥) ---
        function generateShapeData(shape, size, rotation) {
            let data = [];
            
            // 回転を考慮した座標変換ヘルパー
            function rotatePoint(x, z, size, rotation) {
                // 回転の中心を (size/2, size/2) とする
                const centerX = size / 2;
                const centerZ = size / 2;
                let newX = x - centerX;
                let newZ = z - centerZ;
                
                let rotX = newX;
                let rotZ = newZ;

                if (rotation === 90) {
                    rotX = -newZ;
                    rotZ = newX;
                } else if (rotation === 180) {
                    rotX = -newX;
                    rotZ = -newZ;
                } else if (rotation === 270) {
                    rotX = newZ;
                    rotZ = -newX;
                }
                
                // 再度中心を基準に戻す (整数座標へ)
                return {
                    x: Math.round(rotX + centerX),
                    z: Math.round(rotZ + centerZ)
                };
            }

            let shapeBoundingSize = size;
            
            if (shape === 'square') {
                for (let x = 0; x < size; x++) {
                    for (let z = 0; z < size; z++) {
                        data.push({ x, z, color: drawColor });
                    }
                }
                // 回転はバウンディングボックス内で完結するため、回転処理をスキップ
                
            } else if (shape === 'circle') {
                // Midpoint Circle Algorithm の応用
                const r = size / 2;
                const cx = r;
                const cz = r;
                shapeBoundingSize = size + 1;

                for (let x = 0; x <= size; x++) {
                    for (let z = 0; z <= size; z++) {
                        // 中心からの距離が半径以下であれば、ボクセルを置く
                        const distSquared = (x - cx) ** 2 + (z - cz) ** 2;
                        if (distSquared <= r ** 2) {
                            data.push({ x, z, color: drawColor });
                        }
                    }
                }
                
            } else if (shape === 'triangle') {
                // 単純な三角形 (頂点を(0, size), (size, size), (size/2, 0)とする)
                const v1 = { x: 0, z: size };
                const v2 = { x: size, z: size };
                const v3 = { x: Math.floor(size / 2), z: 0 };
                shapeBoundingSize = size + 1;
                
                // 座標(x, z)が三角形内にあるかをチェック
                function isPointInTriangle(x, z, v1, v2, v3) {
                    const sign = (p1, p2, p3) => (p1.x - p3.x) * (p2.z - p3.z) - (p2.x - p3.x) * (p1.z - p3.z);
                    const d1 = sign({ x, z }, v1, v2);
                    const d2 = sign({ x, z }, v2, v3);
                    const d3 = sign({ x, z }, v3, v1);
                    
                    const has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0);
                    const has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);
                    
                    return !(has_neg && has_pos);
                }

                // バウンディングボックス内を走査
                for (let x = 0; x <= size; x++) {
                    for (let z = 0; z <= size; z++) {
                        if (isPointInTriangle(x, z, v1, v2, v3)) {
                            data.push({ x, z, color: drawColor });
                        }
                    }
                }
            }

            // 【回転処理】 (四角以外に適用)
            if (shape !== 'square' && rotation !== 0) {
                const rotatedData = data.map(v => {
                    const rotated = rotatePoint(v.x, v.z, shapeBoundingSize, rotation);
                    return { x: rotated.x, z: rotated.z, color: v.color };
                });
                data = rotatedData;
            }

            // 最終的なバウンディングボックスを計算し直す
            let minX = Infinity, minZ = Infinity, maxX = -Infinity, maxZ = -Infinity;
            data.forEach(v => {
                minX = Math.min(minX, v.x);
                minZ = Math.min(minZ, v.z);
                maxX = Math.max(maxX, v.x);
                maxZ = Math.max(maxZ, v.z);
            });
            
            if (data.length === 0) {
                 return { data: [], clipWidth: 0, clipDepth: 0 };
            }

            // 相対座標を計算 (minX, minZを0にする)
            const finalData = data.map(v => ({
                x: v.x - minX,
                z: v.z - minZ,
                color: v.color
            }));

            return {
                data: finalData,
                clipWidth: maxX - minX + 1,
                clipDepth: maxZ - minZ + 1
            };
        }
        
        // 【図形表示の更新（拡大縮小・回転時）】
        function updateShapeDisplay(gridX, gridZ) {
            if (shapeVoxelData.data.length === 0) return;
            
            // selectionBoxのサイズと位置を更新
            selectionBox.style.width = `${shapeVoxelData.clipWidth * 20}px`;
            selectionBox.style.height = `${shapeVoxelData.clipDepth * 20}px`;

            // 既存のボクセルをクリア（図形を移動/変形するために）
            // 選択/移動モードと同様に、現在の位置のボクセルをクリア
            selectedCells.forEach(cell => {
                voxelData[currentLayer][cell.z][cell.x] = null;
            });

            // 新しいボクセルを書き込む
            selectedCells = [];
            shapeVoxelData.data.forEach(voxel => {
                const newX = gridX + voxel.x;
                const newZ = gridZ + voxel.z;
                if (newX >= 0 && newX < width && newZ >= 0 && newZ < depth) {
                    voxelData[currentLayer][newZ][newX] = voxel.color;
                    selectedCells.push({ x: newX, z: newZ });
                }
            });
            
            updateGridColors();
        }

        // --- 図形プリセットのイベントリスナー (機能④, ⑤) ---
        [circleBtn, squareBtn, triangleBtn].forEach(btn => {
            btn.addEventListener('click', (e) => {
                saveStateForUndo();
                // 描画タブの他のボタンのハイライトをリセット
                drawBtn.style.backgroundColor = '';
                eraseBtn.style.backgroundColor = '';
                
                // 図形ボタンのハイライト
                [circleBtn, squareBtn, triangleBtn].forEach(b => b.style.backgroundColor = '');
                e.target.style.backgroundColor = '#007bff'; 
                
                currentShape = e.target.id.replace('Btn', '');
                shapeSize = Math.floor(Math.min(width, depth) / 4) || 5; // 初期サイズを設定 (最小5)
                shapeRotation = 0; // 初期回転をリセット
                
                shapeVoxelData = generateShapeData(currentShape, shapeSize, shapeRotation);
                if (shapeVoxelData.data.length === 0) {
                    alert("図形サイズが小さすぎるため、ボクセルを生成できませんでした。ブラシサイズを調整してください。");
                    return;
                }
                
                // 中央に配置
                shapeStartGridX = Math.floor((width - shapeVoxelData.clipWidth) / 2);
                shapeStartGridZ = Math.floor((depth - shapeVoxelData.clipDepth) / 2);

                // 選択ボックスを表示し、移動モードへ移行
                selectionBox.style.display = 'block';
                selectionBox.classList.add('moving-box');
                selectionBox.style.width = `${shapeVoxelData.clipWidth * 20}px`;
                selectionBox.style.height = `${shapeVoxelData.clipDepth * 20}px`;
                selectionBox.style.left = `${shapeStartGridX * 20}px`;
                selectionBox.style.top = `${shapeStartGridZ * 20}px`;
                
                updateShapeDisplay(shapeStartGridX, shapeStartGridZ);
                
                setMode('shapeMove');
            });
        });

        // 拡大縮小/回転のロジック
        scaleUpBtn.onclick = () => {
            if (currentMode !== 'shapeMove') return;
            saveStateForUndo();
            shapeSize = Math.min(Math.max(width, depth), shapeSize + 1);
            shapeVoxelData = generateShapeData(currentShape, shapeSize, shapeRotation);
            updateShapeDisplay(shapeStartGridX, shapeStartGridZ);
        };
        scaleDownBtn.onclick = () => {
            if (currentMode !== 'shapeMove') return;
            saveStateForUndo();
            shapeSize = Math.max(1, shapeSize - 1);
            shapeVoxelData = generateShapeData(currentShape, shapeSize, shapeRotation);
            updateShapeDisplay(shapeStartGridX, shapeStartGridZ);
        };
        rotateBtn.onclick = () => {
            if (currentMode !== 'shapeMove') return;
            saveStateForUndo();
            shapeRotation = (shapeRotation + 90) % 360;
            shapeVoxelData = generateShapeData(currentShape, shapeSize, shapeRotation);
            updateShapeDisplay(shapeStartGridX, shapeStartGridZ);
        };
        
        // --- グリッド操作（マウス/タッチ）ロジック（修正） ---

        grid.addEventListener('mousedown', (e) => {
            const cell = e.target.closest('.cell');
            if (!cell) return;
            const x = parseInt(cell.dataset.x);
            const z = parseInt(cell.dataset.z);
            
            if (currentMode === 'draw' || currentMode === 'erase') {
                e.preventDefault();
                isDrawing = true;
                paintCells(x, z);
            } else if (currentMode === 'select') {
                isSelecting = true;
                startCellX = x;
                startCellZ = z;
                selectionBox.style.display = 'block';
                selectionBox.classList.remove('moving-box');
                selectionBox.style.left = `${x * 20}px`;
                selectionBox.style.top = `${z * 20}px`;
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
                e.preventDefault();
            } else if (currentMode === 'move') {
                const rect = selectionBox.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                const selX = Math.round((rect.left - gridRect.left) / 20);
                const selZ = Math.round((rect.top - gridRect.top) / 20);
                const selW = Math.round(rect.width / 20);
                const selD = Math.round(rect.height / 20);
                // クリック位置が選択ボックス内かチェック
                if (x >= selX && x < selX + selW && z >= selZ && z < selZ + selD) {
                    isMoving = true;
                    saveStateForUndo();
                    movingStartMouseX = e.clientX;
                    movingStartMouseY = e.clientY;
                    movingStartGridX = selX;
                    movingStartGridZ = selZ;
                    e.preventDefault();
                } else {
                    clearSelection();
                    setMode('select');
                }
            } else if (currentMode === 'shapeMove') { // 【新規】図形移動開始
                const rect = selectionBox.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                const selX = Math.round((rect.left - gridRect.left) / 20);
                const selZ = Math.round((rect.top - gridRect.top) / 20);
                const selW = Math.round(rect.width / 20);
                const selD = Math.round(rect.height / 20);
                if (x >= selX && x < selX + selW && z >= selZ && z < selZ + selD) {
                    isShapeMoving = true;
                    movingStartMouseX = e.clientX;
                    movingStartMouseY = e.clientY;
                    shapeStartGridX = selX; 
                    shapeStartGridZ = selZ;
                    e.preventDefault();
                } else {
                    // ボックス外をクリックしたら図形モードを確定し、描画モードに戻る
                    document.getElementById('completeSelectionBtn').click(); 
                }
            }
        });

        grid.addEventListener('mousemove', (e) => {
            if (currentMode === 'draw' || currentMode === 'erase') {
                if (!isDrawing) return;
                e.preventDefault();
                const targetElement = e.target;
                if (targetElement && targetElement.classList.contains("cell")) {
                    const moveX = parseInt(targetElement.dataset.x);
                    const moveZ = parseInt(targetElement.dataset.z);
                    paintCells(moveX, moveZ);
                }
            } else if (currentMode === 'select') {
                if (isSelecting) {
                    const cell = e.target.closest('.cell');
                    if (!cell) return;
                    const endX = parseInt(cell.dataset.x);
                    const endZ = parseInt(cell.dataset.z);
                    const minX = Math.min(startCellX, endX);
                    const maxX = Math.max(startCellX, endX);
                    const minZ = Math.min(startCellZ, endZ);
                    const maxZ = Math.max(startCellZ, endZ);
                    selectionBox.style.left = `${minX * 20}px`;
                    selectionBox.style.top = `${minZ * 20}px`;
                    selectionBox.style.width = `${(maxX - minX + 1) * 20}px`;
                    selectionBox.style.height = `${(maxZ - minZ + 1) * 20}px`;
                    cells.flat().forEach(c => c.classList.remove('selecting-cell'));
                    for (let z = minZ; z <= maxZ; z++) {
                        for (let x = minX; x <= maxX; x++) {
                            cells[z][x].classList.add('selecting-cell');
                        }
                    }
                }
            } else if (currentMode === 'move' && isMoving) {
                const dx = Math.round((e.clientX - movingStartMouseX) / 20);
                const dy = Math.round((e.clientY - movingStartMouseY) / 20);
                const newX = movingStartGridX + dx;
                const newZ = movingStartGridZ + dy;
                selectionBox.style.left = `${newX * 20}px`;
                selectionBox.style.top = `${newZ * 20}px`;
            } else if (currentMode === 'shapeMove' && isShapeMoving) { // 【新規】図形移動中
                const dx = Math.round((e.clientX - movingStartMouseX) / 20);
                const dy = Math.round((e.clientY - movingStartMouseY) / 20);
                const newX = shapeStartGridX + dx;
                const newZ = shapeStartGridZ + dy;
                selectionBox.style.left = `${newX * 20}px`;
                selectionBox.style.top = `${newZ * 20}px`;
            }
        });

        window.addEventListener('mouseup', (e) => {
            isDrawing = false;
            if (currentMode === 'move' && isMoving) {
                const dx = Math.round((e.clientX - movingStartMouseX) / 20);
                const dy = Math.round((e.clientY - movingStartMouseY) / 20);
                moveSelectedCells(dx, dy);
                isMoving = false;
            } else if (currentMode === 'shapeMove' && isShapeMoving) { // 【新規】図形移動確定
                const dx = Math.round((e.clientX - movingStartMouseX) / 20);
                const dy = Math.round((e.clientY - movingStartMouseY) / 20);
                
                // 新しい位置を保存し、図形を再描画
                shapeStartGridX += dx; 
                shapeStartGridZ += dy;
                isShapeMoving = false;
                updateShapeDisplay(shapeStartGridX, shapeStartGridZ);
            }
        });
        
        // --- タッチ操作ロジック（修正） ---
        grid.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            const cell = getCellFromPoint(touch.clientX, touch.clientY);
            if (!cell) return;
            const x = parseInt(cell.dataset.x);
            const z = parseInt(cell.dataset.z);
           
            if (currentMode === 'draw' || currentMode === 'erase') {
                e.preventDefault();
                isDrawing = true;
                paintCells(x, z);
            } else if (currentMode === 'select') {
                isSelecting = true;
                startCellX = x;
                startCellZ = z;
                selectionBox.style.display = 'block';
                selectionBox.classList.remove('moving-box');
                selectionBox.style.left = `${x * 20}px`;
                selectionBox.style.top = `${z * 20}px`;
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
                e.preventDefault();
            } else if (currentMode === 'move') {
                const rect = selectionBox.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                const selX = Math.round((rect.left - gridRect.left) / 20);
                const selZ = Math.round((rect.top - gridRect.top) / 20);
                const selW = Math.round(rect.width / 20);
                const selD = Math.round(rect.height / 20);
                if (x >= selX && x < selX + selW && z >= selZ && z < selZ + selD) {
                    isMoving = true;
                    saveStateForUndo();
                    movingStartMouseX = touch.clientX;
                    movingStartMouseY = touch.clientY;
                    movingStartGridX = selX;
                    movingStartGridZ = selZ;
                    e.preventDefault();
                } else {
                    clearSelection();
                    setMode('select');
                }
            } else if (currentMode === 'shapeMove') { // 【新規】図形移動開始
                const rect = selectionBox.getBoundingClientRect();
                const gridRect = grid.getBoundingClientRect();
                const selX = Math.round((rect.left - gridRect.left) / 20);
                const selZ = Math.round((rect.top - gridRect.top) / 20);
                const selW = Math.round(rect.width / 20);
                const selD = Math.round(rect.height / 20);
                if (x >= selX && x < selX + selW && z >= selZ && z < selZ + selD) {
                    isShapeMoving = true;
                    movingStartMouseX = touch.clientX;
                    movingStartMouseY = touch.clientY;
                    shapeStartGridX = selX; 
                    shapeStartGridZ = selZ;
                    e.preventDefault();
                } else {
                    document.getElementById('completeSelectionBtn').click();
                }
            }
        }, { passive: false });

        grid.addEventListener('touchmove', (e) => {
            if (currentMode === 'draw' || currentMode === 'erase') {
                if (!isDrawing) return;
                e.preventDefault();
                const touch = e.touches[0];
                const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
    
                if (targetElement && targetElement.classList.contains("cell")) {
                    const moveX = parseInt(targetElement.dataset.x);
                    const moveZ = parseInt(targetElement.dataset.z);
                    paintCells(moveX, moveZ);
                }
            } else if (currentMode === 'select') {
                if (isSelecting) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const cell = getCellFromPoint(touch.clientX, touch.clientY);
                    if (!cell) return;
                    const endX = parseInt(cell.dataset.x);
                    const endZ = parseInt(cell.dataset.z);
                    const minX = Math.min(startCellX, endX);
                    const maxX = Math.max(startCellX, endX);
                    const minZ = Math.min(startCellZ, endZ);
                    const maxZ = Math.max(startCellZ, endZ);
                    selectionBox.style.left = `${minX * 20}px`;
                    selectionBox.style.top = `${minZ * 20}px`;
                    selectionBox.style.width = `${(maxX - minX + 1) * 20}px`;
                    selectionBox.style.height = `${(maxZ - minZ + 1) * 20}px`;
                    cells.flat().forEach(c => c.classList.remove('selecting-cell'));
                    for (let z = minZ; z <= maxZ; z++) {
                        for (let x = minX; x <= maxX; x++) {
                            cells[z][x].classList.add('selecting-cell');
                        }
                    }
                }
            } else if (currentMode === 'move' && isMoving) {
                e.preventDefault();
                const touch = e.touches[0];
                const dx = Math.round((touch.clientX - movingStartMouseX) / 20);
                const dy = Math.round((touch.clientY - movingStartStartY) / 20);
                const newX = movingStartGridX + dx;
                const newZ = movingStartGridZ + dy;
                selectionBox.style.left = `${newX * 20}px`;
                selectionBox.style.top = `${newZ * 20}px`;
            } else if (currentMode === 'shapeMove' && isShapeMoving) { // 【新規】図形移動中
                e.preventDefault();
                const touch = e.touches[0];
                const dx = Math.round((touch.clientX - movingStartMouseX) / 20);
                const dy = Math.round((touch.clientY - movingStartMouseY) / 20);
                const newX = shapeStartGridX + dx;
                const newZ = shapeStartGridZ + dy;
                selectionBox.style.left = `${newX * 20}px`;
                selectionBox.style.top = `${newZ * 20}px`;
            }
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            isDrawing = false;
            if (currentMode === 'move' && isMoving) {
                const dx = Math.round((e.changedTouches[0].clientX - movingStartMouseX) / 20);
                const dy = Math.round((e.changedTouches[0].clientY - movingStartMouseY) / 20);
                moveSelectedCells(dx, dy);
                isMoving = false;
            } else if (currentMode === 'shapeMove' && isShapeMoving) { // 【新規】図形移動確定
                const dx = Math.round((e.changedTouches[0].clientX - movingStartMouseX) / 20);
                const dy = Math.round((e.changedTouches[0].clientY - movingStartMouseY) / 20);
                
                // 新しい位置を保存し、図形を再描画
                shapeStartGridX += dx; 
                shapeStartGridZ += dy;
                isShapeMoving = false;
                updateShapeDisplay(shapeStartGridX, shapeStartGridZ);
            }
        });
        
        // --- 選択・移動ロジック（既存 + 修正） ---

        function moveSelectedCells(dx, dy) {
            if (selectedVoxelData.length === 0) return;
            // 古い場所のボクセルを消し、新しい場所に描画し直す
            saveStateForUndo();
            // 移動前の場所からデータをクリア
            selectedCells.forEach(cell => {
                voxelData[currentLayer][cell.z][cell.x] = null;
            });
            const newGridX = movingStartGridX + dx;
            const newGridZ = movingStartGridZ + dy;
            const newSelectedCells = [];
            selectedVoxelData.forEach(voxel => {
                const newX = newGridX + voxel.x;
                const newZ = newGridZ + voxel.z;
                if (newX >= 0 && newX < width && newZ >= 0 && newZ < depth) {
                    voxelData[currentLayer][newZ][newX] = voxel.color;
                    newSelectedCells.push({ x: newX, z: newZ });
                }
            });
            // 移動後の位置を次の移動の開始位置として設定
            movingStartGridX = newGridX;
            movingStartGridZ = newGridZ;
            selectedCells = newSelectedCells;
            updateGridColors();
            if (is3DInitialized) update3DView();
        }

        function saveStateForUndo() { 
            const clone = voxelData.map(layer => layer.map(row => row.slice() ) ); 
            undoStack.push(clone); 
            if (undoStack.length > 20) undoStack.shift(); 
        } 
        undoBtn.addEventListener('click', undo); 
        resetBtn.addEventListener('click', () => { 
            saveStateForUndo(); 
            initData(); 
            renderGrid(); 
            if (is3DInitialized) update3DView(); 
        });

        // --- レイヤー操作（既存 + 新規追加） --- 
        // レイヤー切り替え（既存） 
        layerPrevBtn.addEventListener('click', () => { 
            if (currentLayer > 0) { 
                currentLayer--; 
                renderGrid(); 
                updateLayerLabel(); 
            } 
        });

        layerNextBtn.addEventListener('click', () => { 
            if (currentLayer < height - 1) { 
                currentLayer++; 
                renderGrid(); 
                updateLayerLabel(); 
            } 
        });

        // レイヤーコピーして追加機能 (新規追加) 
        copyLayerAddBtn.addEventListener('click', () => { 
            if (height >= 64) { 
                alert("最大レイヤー数 (64) に達しているため、これ以上追加できません。"); 
                return; 
            } 
            saveStateForUndo(); 
            // 1. 新しいレイヤーのデータを準備 (現在のレイヤーのディープコピー) 
            const newLayerData = voxelData[currentLayer].map(row => row.slice()); 
            // 2. voxelData配列に新しいレイヤーを挿入 
            // heightを1増やす 
            height++; 
            // 新しいレイヤー（コピーデータ）を現在のレイヤーの直上（インデックス + 1）に挿入 
            voxelData.splice(currentLayer + 1, 0, newLayerData); 
            currentLayer++; // 新しいレイヤーに移動 
            // 3. UIの更新 
            document.getElementById('inputHeight').value = height; 
            updateLayerLabel(); 
            initGrid(); // グリッドの高さが変わったので再構築が必要
            renderGrid(); 
            if (is3DInitialized) update3DView(); 
            alert(`レイヤー ${currentLayer} をコピーして、新しいレイヤー ${currentLayer + 1} を上に追加しました。`); 
        });

        // --- その他のヘルパー関数（既存） --- 
        function undo() { 
            if (undoStack.length === 0) return; 
            voxelData = undoStack.pop();
            // height, width, depth も undo で戻せるようにするべきだが、今回はデータのみ
            if (currentLayer >= height) currentLayer = height - 1; 
            updateGridColors(); 
            updateLayerLabel(); 
            if (is3DInitialized) update3DView(); 
        } 

        function initData() { 
            voxelData = Array.from({ length: height }, () => Array.from({ length: depth }, () => Array.from({ length: width }, () => null) ) ); 
        } 
        
        // ... (initGrid, renderGrid, paintCells, updateLayerLabel は変更なし)

        // 【updateGridColorsの修正 (機能②)】
        function updateGridColors() {
            if (cells.length === 0) return;
            for (let z = 0; z < depth; z++) {
                for (let x = 0; x < width; x++) {
                    const cell = cells[z][x];
                    const color = voxelData[currentLayer][z][x];
                    const isSelected = selectedCells.some(c => c.x === x && c.z === z);
                    
                    // 【修正】選択中のセルは背景色を半透明にする (機能②)
                    if (isSelected && color) {
                        // 透過度 0.6 を適用
                        cell.style.backgroundColor = hexToRgba(color, 0.6);
                    } else {
                        cell.style.backgroundColor = color ?? "transparent";
                    }
                    
                    // selected-cellクラスは、移動中のボクセルにボーダーを表示するために使用
                    cell.classList.toggle('selected-cell', isSelected);
                }
            }
        }
        
        // ... (init3DView, update3DView は変更なし)

        // --- 画像処理関連（既存 + 修正） ---
        // ... (imageInput, applyImageSizeBtn, toggleMoveImageBtn, deleteImageBtn は変更なし)
        
        // 【convertImageTo3dBtnの修正 (機能①: オフセット反映)】
        convertImageTo3dBtn.addEventListener('click', () => {
            if (!overlayImage || !overlayImage.src) {
                alert("画像をインポートしてください。");
                return;
            }
            sideSelectionDiv.style.display = 'block';
            
            // 【新規追加】画像オフセットの取得 (ピクセルからセル単位へ)
            const offsetLeft = overlayImage ? Math.round(parseFloat(overlayImage.style.left) / 20) : 0;
            const offsetTop = overlayImage ? Math.round(parseFloat(overlayImage.style.top) / 20) : 0;

            const buttons = sideSelectionDiv.querySelectorAll('button:not(#cancelBtn)');
            buttons.forEach(button => {
                button.onclick = (e) => {
                    const side = e.target.dataset.side;
                    sideSelectionDiv.style.display = 'none';

                    saveStateForUndo();

                    // ... (既存の canvas, ctx, img の初期化ロジック)

                    img.onload = () => {
                        // ... (既存の画像描画ロジック)

                        const imageData = ctx.getImageData(0, 0, img.width, img.height).data;
                        const imgWidth = parseInt(imgWidthInput.value);
                        const imgHeight = parseInt(imgHeightInput.value);
                        
                        // 画像サイズとグリッドサイズの比率
                        const scaleX = img.width / imgWidth;
                        const scaleY = img.height / imgHeight;

                        for (let x = 0; x < imgWidth; x++) {
                            for (let y = 0; y < imgHeight; y++) {
                                // 描画ピクセル位置
                                const px = Math.floor(x * scaleX);
                                const py = Math.floor(y * scaleY);

                                const index = (py * img.width + px) * 4;
                                const r = imageData[index];
                                const g = imageData[index + 1];
                                const b = imageData[index + 2];
                                const a = imageData[index + 3];

                                if (a < 128) continue; // 半透明以下はスキップ

                                // RGBをHEXに変換
                                const hexColor = '#' + [r, g, b].map(c => c.toString(16).padStart(2, '0')).join('');
                                
                                let voxelX, voxelY, voxelZ;

                                // 【修正】オフセットを反映 (機能①)
                                if (side === 'front') {
                                    voxelX = x + offsetLeft;
                                    voxelY = height - 1 - (y + offsetTop);
                                    voxelZ = depth - 1;
                                } else if (side === 'back') {
                                    voxelX = width - 1 - (x + offsetLeft);
                                    voxelY = height - 1 - (y + offsetTop);
                                    voxelZ = 0;
                                } else if (side === 'left') {
                                    voxelX = 0;
                                    voxelY = height - 1 - (y + offsetTop);
                                    voxelZ = depth - 1 - (x + offsetLeft);
                                } else if (side === 'right') {
                                    voxelX = width - 1;
                                    voxelY = height - 1 - (y + offsetTop);
                                    voxelZ = x + offsetLeft;
                                } else if (side === 'top') {
                                    voxelX = x + offsetLeft;
                                    voxelY = height - 1;
                                    voxelZ = y + offsetTop;
                                } else if (side === 'bottom') {
                                    voxelX = x + offsetLeft;
                                    voxelY = 0;
                                    voxelZ = y + offsetTop;
                                }

                                // 境界チェック
                                if (voxelX >= 0 && voxelX < width && voxelY >= 0 && voxelY < height && voxelZ >= 0 && voxelZ < depth) {
                                    voxelData[voxelY][voxelZ][voxelX] = hexColor;
                                }
                            }
                        }
                        updateGridColors();
                        if (is3DInitialized) update3DView();
                    };
                    img.src = overlayImage.src;
                };
            });
        });

        cancelBtn.addEventListener('click', () => {
            sideSelectionDiv.style.display = 'none';
        });

        initData();
        updateLayerLabel();
        initGrid();
        updateGridColors();
        setMode('draw');
        window.addEventListener('resize', () => {
            if (is3DInitialized) {
                renderer.setSize(rendererContainer.clientWidth, rendererContainer.clientHeight);
                camera.aspect = rendererContainer.clientWidth / rendererContainer.clientHeight;
                camera.updateProjectionMatrix();
            }
        });
    </script>
</body>
</html>
